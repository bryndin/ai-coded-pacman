# Developers Journal

This is an experiment to implement Pacman using the code generated by public LLMs.

## Step 1

***Prompt:***
Using a p5 library generate code for the classic Pacman game. Make sure the code can run.

> [!NOTE]
>
> - MS Copilot generates HTML file with JS code inline that only shows black canvas. Logic there is a no-go hallucination.
> - Gemini does generate a reasonable code. But it runs out of tokens and the code is unfinished. Need to find a workaround.

## Step 2

**Problem:** Code is not fully generated and is incorrect. Parts of the `Pacman` class aren't generated.

***Prompt:***
From the code above, only show the Pacman class

> [!NOTE]
>
> - Asked to generate class Pacman separately and now code is syntactically correct.
> - The code refers to Ghost class that is not defined anywhere.
> - Nothing is being drawn.

## Step 3

**Problem:** Nothing is being rendered. `setup` function is referring to `Ghost` class that is not defined.

***Prompt:***
`setup` function refers to `Ghost` that is not defined. Can you create a class for `Ghost`?

> [!NOTE]
>
> - Canvas was empty and the code is clearly missing the `Ghost` class, that we asked Gemini to generate.
> - Adding the newly generated `Ghost` class fixed the code and now we have at least maze and pacman visuals.
> - Ghosts aren't shown. Can't control pacman. No interactivity in general.

![Visuals after Step 3](/screenshots/step3.png)

## Step 4

**Problem:** Pacman doesn't respond to keyboard movements.

***Prompt:***
Pacman is not moving. How is it supposed to be controlled and what is the problem with that code?

***Answer (shortened):***

```markdown
Missing getAngle function: The show method in the Pacman class references a getAngle function that's not defined. This function is likely used to determine the direction Pacman is facing to draw the mouth correctly.

Incomplete canMove function: The canMove function only defines the logic to get the grid coordinates of the intended move but lacks the actual collision check with walls. It needs to check if the corresponding grid position in grid is "WALL" to prevent movement.

Missing update loop: The draw function doesn't have a loop to continuously update the game state. This means Pacman's position and direction won't change between frames, making it seem like it's not moving.
```

***Actions:***

- Adding `getAngle` function to `Pacman` class.
- Add wall checking logic to `canMove` method.
- Updated `draw` function doesn't have duplicated Ghost drawing rows.
- Newly added logic to `draw` related to `canMove` decisions is broken. Pacman is not rendered anymore.

## Step 5

**Problem:** Pacman stopped rendering as the result of the previous step.

***Prompt:***
Rendering of pacman broke, what is wrong with canMove related logic in the `draw` function?

***Answer (shortened):***

```markdown
The issue with the canMove related logic in the draw function is related to a variable typo. Here's the breakdown:

Typo in variable name: Inside the draw function, you're using gridy to access the grid array, but this variable isn't defined anywhere. It should be gridY which is correctly defined within the canMove function of the Pacman class.

Incorrect usage of `gridY`: The `canMove` function returns `grid[gridy] && grid[gridy][gridX] !== "WALL"`. This checks if `grid[gridy]` exists (which might be undefined due to the typo) and then checks its element at gridX. However, within the draw function, you're only using gridY for the first check, but not for accessing the element within the grid.
```

> [!NOTE]
> Gemini generates code with errors. We saw code given unfinished. Code referring to undefined classes and functions. Typos in variables, e.g. casing typos.

***Actions:***

- Fix `gridy` typos that must be `gridY` in `Pacman.canMove`.

Pacman is rendered again. Ghost appears too.
Pacman moves up on arrow key press, but not down or right.
Walls need fixing too, as Pacman position is inside the wall.

![Visuals after Step 5](/screenshots/step5.png)

## Step 6

**Problem:** Maze doesn't make sense and Pacman is positioned in the wall. Instead we want to have the classic level of 28x36 grid. Original tiles were 8x8 pixel, it's too small for modern screens, we can do 16x16 or 32x32.

***Prompt:***
Modify `createGrid` function to generate the classical pacman level with the grid of 28x36.

***Answer (shortened):***

```markdown
Here's the modified createGrid function to generate a classic Pacman level with a grid of 28x36:

<- code ->

This code defines an innerWalls array containing objects that specify coordinates for horizontal and vertical walls. The loop iterates through these objects and marks the corresponding cells in the grid with "WALL".
```

> [!NOTE]
>
> - This is a basic example.
> - Rendering broke again.

***Actions:***

- Replace `createGrid()` with the newly generated code.

## Step 7

**Problem:** Maze rendering broke.  It's not clear why Gemini insists on generating outer walls. Inner walls mix horizontal and vertical walls with different schemas.

***Prompt:***
There is a problem in `createGrid` can you identify and fix it?

***Answer (shortened):***

```markdown
The issue lies in the way the innerWalls array defines horizontal walls. Here's the breakdown:

Incorrect x-coordinate range for horizontal walls: The objects in the innerWalls array for horizontal walls define x1 and x2 to represent the starting and ending positions on the x-axis. However, these values should represent the column indexes in the grid, which range from 0 to width/cellSize - 1 (exclusive).
Currently, the code defines x2 as the ending position for drawing the wall. Since the loop iterates from x1 to x2 (inclusive), it will try to mark one extra cell beyond the intended end position  as "WALL" which might cause issues with rendering or collision detection.

Here's how to fix it:

<- code ->

By adjusting x2 in the horizontal wall definitions to be one less than the intended ending position, the loop will iterate up to the correct cell (inclusive), ensuring the wall is drawn within the grid boundaries.
```

***Actions:***

- This is not the problem breaking rendering, but the fact `createGrid()` redefines the global `grid` variable. Asking again

***Prompt:***
Why `createGrid` redefines `grid` that is already a global variable?

***Answer (shortened):***

```markdown
You're right, redefining grid inside the createGrid function might be unnecessary and can be confusing. Here's why it happens and how to improve it:

JavaScript variable scope: JavaScript has two main variable scopes: global and local. Variables declared outside any function (like grid here) are globally accessible. Variables declared within a function are local to that function.

Reassignment vs. redeclaration: In the createGrid function, you're not technically redeclaring grid. You're assigning a new empty array to the existing grid variable. This effectively wipes out any previous content in grid.

There are two ways to improve this:

Option 1: Utilize existing grid variable directly:

<- code ->

This approach removes the line grid = []; and directly uses the grid variable within the function. Since grid is already defined globally, it's accessible within the function.

Option 2: Use a local variable within createGrid:

<- code ->

This approach defines a local variable localGrid within the function to build the grid. After the loop finishes creating the grid structure, it assigns the entire localGrid to the global grid variable.

Both approaches achieve the same functionality but with slightly different strategies for handling the grid data. Choose the one that you find clearer or more suitable for your code organization.
```

***Actions:***

- Let's go with Option 2, but instead of assigning `grid = localGrid;` inside of it, lets ask `createGrid()` to return it.

***Prompt:***
Modify Option 2 to return `localGrid` instead of assigning it to `grid` variable. Modify the call to `createGrid` to use that returned value.

***Answer (shortened):***

```markdown
Here's the modified code utilizing Option 2 with createGrid returning the generated grid:

1. Modified createGrid function:

<- code ->

Instead of assigning the local grid to the global grid variable, the function now returns the localGrid using the return statement.

2. Modified call to createGrid:
   
<- code ->

In the setup function, the call to createGrid is used, and the returned value (the generated grid) is assigned to the global grid variable. This eliminates the need for direct assignment within the function.

This approach keeps the grid creation logic encapsulated within the createGrid function and separates it from modifying the global grid variable directly.
```

***Actions:***

- Rendering is still broken, because global `grid` is defined as a `const`. switch it to `let` similar to `pacman` and `ghosts`. Now it does render.

Only outer walls are rendered correctly. Canvas and grid size didn't change and is still a square.

![Visuals after Step 7](/screenshots/step7.png)

## Step 8

**Problem:** Grid is still 10x10, not 28x36. Canvas size is not increased either.

***Prompt:***
Change canvas size to accommodate the 28x36 grid with the cell size of 16 pixels.

***Answer (shortened):***

```markdown
To accommodate a 28x36 grid with a cell size of 16 pixels, you'll need to adjust the canvas size in the setup function. Here's the modified code:

<- code ->
```

> [!NOTE]
>
> - cell size is hardcoded: `const gridWidth = 28 * 16;`
> - It doesn't mention that `const cellSize = 40;` needs updating too, and thus all rendering is of size 40, not 16.

***Prompt:***
Cells are still of size 40 pixels, not 16.  Help to update.

***Answer (shortened):***

```markdown
You're right, the cells are still rendering at 40 pixels even though the canvas size is adjusted. The cell size is determined by how you draw elements within the grid. Here's how to fix it:

Update drawing functions: The size of the Pacman, ghosts, and potentially other elements in your code is likely defined based on the cell size. You need to update these drawing functions to use the actual cell size (16 pixels) instead of assuming it's the same as the canvas size.
Here are some examples:

Pacman:
<- code ->
```

> [!NOTE]
>
> - This is wrong. Gemini seem to forget about global `const cellSize = 40;` and instead suggests to hack Pacman and Ghost size `this.size = cellSize - 5; // Update size based on actual cellSize (16)`

***Prompt:***
Should I update the global cellSize instead?

***Answer:***

```markdown
No, it's generally better practice to avoid updating the global cellSize variable in this scenario. Here's why:

Maintainability: Using the actual cellSize (16) directly within the drawing functions makes the code clearer and easier to understand. It removes the need to mentally track the value of a global variable and its potential modifications throughout the code.

Flexibility: If you ever decide to change the cell size in the future, you only need to modify the value used within the drawing functions instead of updating a single global variable and potentially affecting other parts of the code unintentionally.

Encapsulation: Keeping the cell size definition within the context of the drawing functions promotes better encapsulation. Each function becomes more self-contained, relying on the provided cellSize value to draw elements correctly.

While there's nothing technically wrong with updating the global cellSize, the approaches mentioned above offer several advantages for code maintainability, flexibility, and clarity.
```

> [!NOTE]
>
> - This is plain wrong. Based on the original code generated. Gemini suggests to keep the original `40` that it came up with. Instead hack Pacman and Ghost. This doesn't solve the problem with wall sizes.
> - I'm going to fix it myself as it's pretty obvious change.

![Visuals after Step 8](/screenshots/step8.png)

## Step 9

**Problem:** Only the outer walls are generated, not the inner ones.

***Prompt:***
createGrid only generates the outer walls, but not the inner ones. Find and fix the problem there.

***Answer (shortened):***

```markdown
The problem lies in the conditional statement within the loop that creates the outer walls in the createGrid function. Here's the breakdown:

Outer wall condition: The current condition checks if x === 0 || x === width / cellSize - 1 || y === 0 || y === height / cellSize - 1 to mark cells as "WALL" for the outer boundaries.

Inner walls not considered: This condition only checks the edges of the grid (based on cell size and canvas size). It doesn't account for any additional walls you might want to define within the grid itself.

Here's how to fix it:

Option 1: Modify the loop condition (less flexible):

<- code ->

This approach changes the condition to true to mark all cells as "WALL" initially. Then, you'll need to add another loop or logic specifically designed to define the inner walls and set their corresponding positions in the grid to "EMPTY".

Option 2: Use a separate loop for inner walls (more flexible):

<- code ->

This approach keeps the outer wall creation logic. Then, it introduces a separate loop that iterates through the innerWalls array (defined as before) to set the corresponding cells in the grid to "WALL".

Option 2 is generally preferred as it allows for more flexibility in defining the inner walls without affecting the outer wall creation logic.
```

> [!NOTE]
>
> - Option 1 is meaningless, broken logic and doesn't take the inner walls in account at all.
> - Option 2 is exactly what the current broken logic does.

***Prompt:***
Why innerWalls array mixes names, for example some elements use {y, x1, x2} names while the other use {y1,y2, x}?  Does it work correctly with the nested for loops operating on innerWalls.forEach?

***Answer (shortened):***

```markdown
You're right, there's an inconsistency in the naming conventions used within the innerWalls array for defining walls. This inconsistency can lead to confusion and potential errors.
```

> [!NOTE]
>
> - While Gemini does claim inconsistency can be a problem, the newly generated code is exactly the same as it was before.

***Prompt:***
Should innerWalls be split into 2 arrays, for horizontal and vertical walls,  and the forEach loops be modified accordingly?

***Answer:***

```markdown
Splitting the innerWalls array into separate arrays for horizontal and vertical walls is a good approach and can improve code organization and readability. Here's how to implement it:

1. Separate arrays:
<-code->
2. Modified forEach loops:
<-code->

The loops now iterate through the respective arrays and use consistent naming for the loop variables (y for horizontal walls and x for vertical walls) based on the wall type being processed.

Advantages:

- Improved Readability: Separating walls by type makes the code easier to understand and maintain.
- Flexibility: Adding or removing walls of a specific type becomes simpler as you only need to modify the corresponding array.
- Maintainability: If the logic for processing horizontal and vertical walls differs, you can handle them within separate loops.
- This approach provides a well-organized way to define and manage the inner walls in your Pacman level.
```

> [!NOTE]
>
> - generated code uses `grid` not the `localGrid` we changed previously. This could be due to Gemini not knowing which option of the previous 2 we picked.
> - The walls look nothing like the classic pacman level.

## Step 10

***Prompt:***
Based on this picture of the classic Pacman game level, where walls are of blue color, generate the inner walls coordinates for `horizontalWalls` and `verticalWalls` arrays in our Pacman game.

***Answer:***

```markdown
Absolutely, based on a classic Pacman game level where walls are blue colored, here's a possible set of coordinates for the horizontalWalls and verticalWalls arrays:

Horizontal Walls (horizontalWalls array):

<-code->

Vertical Walls (verticalWalls array):

<-code (unfinished) ->
```

> [!NOTE]
>
> - Code was cut short. Had to ask to print the `verticalWalls` separately.
> - Resulted walls have nothing in common with the level we need.
> - Microsoft Copilot can't generate one either, replacing entries with comments, generating rows of different length and being in overall a waste of time.
> - Remove all the generating logic and replace it with a static array representing the level.
> - Replace "WALL" with 1
> - Hand draw the level

## Step 11

**Problem:** Pacman doesn't go right.

***Prompt:***

1. Pacman can move left, up and down, but doesn't move right. Fix it.
2. Is there a problem in `keyPressed()` function?

> [!NOTE]
>
> - Gemini is unable to find the typo in "RIGHT_arrow". Let's fix it ourselves.

## Step 12

**Problem:**

- Pacman doesn't align to the grid. It's shifted half a cell.
- Pacman's speed is too fast.

***Prompt:***
Pacman moves too fast, how to make it move slower and smooth?

***Answer:***

```markdown
There are a couple of approaches you can take to make Pacman move slower and smoother in your Pacman game:

1. Timer-based Movement:
<- code ->
2. Animation Loop:
<- code ->
```

***Prompt:***
Current logic in Pacman.move() makes Pacman move my a cell size. Make a better, more smooth per-pixel movement.

***Answer:***

```markdown
You're right, moving Pacman by a full cell size in each update can feel clunky. To achieve smoother per-pixel movement, we can leverage concepts like animation and frame rates. Here's an approach using requestAnimationFrame:

1. Update Pacman's Movement Speed:

Define a variable, for example, pacman.speed, to represent Pacman's movement speed in pixels per frame. A common starting point could be something like 2 pixels per frame.

2. Calculate Movement Distance:

Instead of directly moving Pacman by a full cell size, calculate the distance to move based on the speed and the time elapsed since the last update.
Here's an improved Pacman.move() function:

<- code ->
```

> [!NOTE]
>
> - `Pacman.move()` method is not being used.. It duplicates the logic in `draw()` function.

***Prompt:***
I don't see the move() function being used anywhere. Is it correct?

> [!NOTE]
>
> - Gemini started refactoring code to use `pacman.direction` `"RIGHT"` etc. instead of the previous logic of `setDirection(x, y)` operating on `pacman.directionX` and `pacman.directionY`

***Prompt:***
I don't see the move() function being used anywhere. Is it correct?

***Prompt:***
There is already a method `setDirection(x,y)` under Pacman class. Should the pacman's `directionX` and `directionY` attributes be used instead of newly introduced `direction` attribute?

***Answer (shortened):***

```markdown
You're absolutely right. It's better to leverage the existing setDirection(x, y) method and directionX and directionY attributes for Pacman's movement logic if they're already present in your codebase. Here's how to adapt the approach:
```

> [!NOTE]
>
> - `Pacman.move()` is still not used.

***Prompt:***
Show me how to integrate `Pacman.move()` into the animation loop using `requestAnimationFrame`. Dose grid and ghost drawing need updating?

> [!NOTE]
>
> - It explains how to use `requestAnimationFrame` with the new `animate()` function that will call `Pacman.move()`.
> - Not clear why do we need that `animate()` logic, if there is already the `draw()` function.

***Prompt:***
How does the new `animate()` function relate to the existing `draw()` function that is responsible for drawing? Do we need to use both?

> [!NOTE]
>
> - While what Gemini describes with splitting `animate()` and `draw()` makes sense, the `draw()` is the p5s lib callback.

***Prompt:***
Isn't our current `draw()` function part of p5js game library and that library calls it instead of us calling it directly?

***Answer (shortened):***

```markdown
You're absolutely correct. I apologize for the confusion in the previous explanation.

In the context of p5.js, the draw() function is indeed a core function provided by the library.  Here's a more accurate explanation:
```

> [!NOTE]
>
> - The movement and drawing logic gets more and more entangled.

***Prompt:***
Show me the overall `draw()` and the pacman's `move()` function.

> [!NOTE]
>
> - At this point Gemini starts going in loops and doesn't have a good history of our code. It started providing the general code that is a variation of what it suggested initially.
> - It's time to switch prompts to more precise and detailed ones. See if that can make some progress.

***Prompt:***
How does the `Pacman.move()` method is used with `Pacman.canMove(x,y)` method?

***Prompt:***
The current `move()` function operated with x and y being the pixels of the top left corner of the pacman. This function uses `canMove(x,y)` function that checks if pacman can move into a new location not occupied by the wall declared in the `grid` array.  But it `canMove(x,y)` only checks for the top left coordinates of pacman. Update `canMove` function to check all 4 corners.

> [!NOTE]
>
> - Lengthy reply is not that useful. It suggests doing 4 checks and OR-ing the checks, but that's what we already asked. The rest of code is useless restatements.
> - A few more tries to generate `canMove` that checks all 4 corners results in bad code offsetting `gridX` and `gridY` instead of `x` and `y`
> - Instead reuse the idea of top 4 corners, but have to implement it myself.

## Step 13

**Problem:** Pacman must not stop if keyboard command can't change that direction immediately, but instead apply it at the next possibility.

***Prompt:***
Already moving pacman stops if a new keyboard command points him into the wall. How does the `move()` `draw()` and `keyPressed()` functions need to change to ignore the change of direction if it's not possible at this moment?

> [!NOTE]
>
> - Gemini suggest to add "desired direction" that updates "direction" when pacman can move in the "desired" direction, but it's a faulty logic.

***Prompt:***
In the code above, while moving left the change in "desiredDirection" to go up will wrongly change the"pacmanDirection".

> [!NOTE]
>
> - Better, but with the repeating logic

***Prompt:***
Good, but there is a repeating logic that can be factored out into a function. Is it worth doing that?

***Prompt:***
Another problem is the code is missing the second check for `canMove` function. If else is executed no more collision check happens.

> [!NOTE]
>
> - Gemini keeps generating buggy code and have to be pointed out to fix it.

## Step 14

**Problem:** Ghosts aren't moving. Add the chasing logic. Also Pacman can't enter some of the tunnels.

***Prompt:***
Ghosts aren't moving, add logic to chase Pacman.

> [!NOTE]
>
> - Gemini provides the "simple chase logic" to define the direction. Code is reasonable, but needs heavy adaption from the `Pacman.move()`. At the end the chase, though a simple one, works.

## Step 15

**Problem:** Simple chase logic is too simple. Can Gemini help us to build a smarter one from the classic implementation of Pacman?

***Prompt:***
Can you provide a more complex chase logic that is used in real implementations of Pacman?

***Answer:***

```markdown
Absolutely! While the simple chase logic in the previous response provides a starting point, real Pacman implementations often utilize a combination of techniques for more interesting and challenging ghost behavior. Here's a breakdown of some common approaches:

1. Target Grid Approach:

Divide the maze into a grid of smaller cells.
For each ghost, define a target grid cell based on Pacman's current location or a predetermined pattern (e.g., scatter points).
The ghost uses a pathfinding algorithm (like A*) to find the shortest path to its target cell, avoiding walls.

2. Chasing Modes:

Implement different chasing modes for ghosts, like:
Chase Mode: Ghosts actively chase Pacman using the target grid approach.
Scatter Mode: Ghosts move away from specific scatter points in the maze (can be timed or triggered by Pacman's actions).
Frightened Mode: Ghosts become vulnerable and move randomly when Pacman eats a power pellet.

3. Field of View (FOV) Optimization:

Ghosts don't have complete knowledge of the entire maze.
Implement a limited field of view for each ghost, restricting their awareness of Pacman's location to nearby grid cells.
This can be achieved using techniques like raycasting or pre-calculated visibility maps.

4. Teaming and Cooperation:

In advanced versions, ghosts might collaborate.
For example, a chasing ghost might communicate Pacman's location to a strategically positioned ghost to cut him off.
Here's an example incorporating some of these ideas:

<-code->

Remember:

Replace the placeholder functions (getClosestPacmanCell, getScatterCell, findPath, getDirectionTowards) with your specific implementations based on your chosen pathfinding algorithm and FOV approach.
Adjust the chase threshold, ghost modes, and other parameters to fine-tune the ghost behavior for your game.
```

***Prompt:***
Generate `getDirectionTowards` function for the code above

> [!NOTE]
>
> - Generates the "simple chase" approach similar to what we used before.

***Prompt:***
Generate `findPath` function for the `ghostMove` function above.

***Answer (shortened):***

```markdown
The findPath function in the context of Pacman ghost AI typically involves a pathfinding algorithm to find the shortest path from the ghost's current position to a target cell within the maze. Here's an example using a basic Breadth-First Search (BFS) approach:
<- code ->
```

> [!NOTE]
>
> - Need a helper function that will look at the grid to filter out the wall cells.

***Prompt:***
Generate code for the `getValidNeighbors(x,y)` function that will look at the grid to avoid cells with walls.

> [!NOTE]
>
> - Great, we got something reasonably looking!
> - Path finding functions use grid coordinates, while pacman anf ghost use canvas ones. Need a function to convert between them

***Prompt:***
Create a function to convert from the canvas coordinates in pixels to cell coordinates in the grid.

> [!NOTE]
>
> - Since `Ghost.move()` method is a hack of several suggestions from Gemini, I had to patch it manually with proper conversions from the canvas coords into the grid coords using `canvasToGridCell()` Gemini just generated. Some hacking required to pass "cell" object instead Ghost or Pacman instances.
> - Ghosts are shown and move, but the movement is clearly broken.
> - At least nothing leads to code freezing.

## Step 16

**Problem:** Pacman is unable to enter some of the tunnels. This problem existed even before the addition of ghost logic. It's time to look at it, as it may affect the AI behind ghosts.

***Prompt:***
Pacman can't turn into some of the paths. Look at the Pacman movement code and see if something is wrong there.

***Answer (shortened):***

```markdown
Absolutely! Let's analyze the Pacman movement code to identify potential issues that might prevent him from turning into some paths:

Common Issues:

Collision Check Order:

Make sure the collision check happens after the desired direction change is applied to Pacman's position.
If the collision check is done before updating the position, it might prevent Pacman from entering a valid path even if the new position wouldn't lead to a collision.
Incomplete Collision Checking:

Ensure your canMove function considers all four corners of Pacman when checking for collisions with walls.
A simple check for the center of Pacman might miss collisions when entering narrow passages or making sharp turns.
Cell Snapping:

If you're using a cell-based approach for movement, there might be issues where Pacman's position gets snapped to the center of a cell after a movement update.
This can cause him to get stuck in corners or miss narrow paths if the snapping logic doesn't account for his desired direction.
Floating-Point Precision Errors:

Depending on how you calculate Pacman's movement based on speed and time, you might encounter floating-point precision errors.
These errors can lead to slight discrepancies between the intended movement and the actual position, potentially causing Pacman to miss some paths.
Code Review:

Here's a breakdown of some things to look for in your Pacman movement code:
```

> [!NOTE]
>
> - This is due to the `speed` variable set to 100. It causes Pacman to jam over the coordinates needed to enter the turn.

***Prompt:***
The problem happens due to the high speed value that causes pacman position to jump over the x,y coordinates corresponding to the wall opening cell. Suggest a code change to fix the problem.

***Answer:***

```markdown
Absolutely! You're right, a high speed value can cause Pacman to overshoot wall openings. Here's a code change to address this issue:

1. Movement Based on Cell Size:

Instead of directly calculating movement distances based on speed and time, we can tie the movement to the size of a cell in the grid. This ensures Pacman's movement aligns perfectly with the grid and avoids overshooting openings.

Here's an example code change:
<- code ->

2. Alternative: Snapping with Threshold

If directly calculating movement distances is preferred, you can implement a snapping mechanism with a threshold:
<- code ->
```

> [!NOTE]
>
> - Option 1 is a no go. It will make Pacman jump from cell to cell and will get in the way of animation, control etc. Won't work without some tricky animation based solutions on top.
> - Option 2 with snapping to the grid should work. Let's try it.

***Prompt:***
Factor out the snapping logic into a reusable function.

> [!NOTE]
>
> - Refactoring Gemini did is interesting: `function snapToCell(position, cellSize, threshold = 0.1 * cellSize) {` . `cellSize` is not used in the body of the function, only for the default value of `threshold`

***Prompt:***
Do we need to pass `cellSize` to `snapToCell` function?

***Answer (shortened):***

```markdown
You're right, there are ways to avoid passing cellSize to the snapToCell function every time. Here are two approaches:

1. Global Cell Size Variable:
2. Function Argument with Default Value:
```

> [!NOTE]
>
> - Gemini can't set it's mind on data structures. We have classes, array like objects representing x,y coords and the separate vars for x and y. Similar problem with canvas vs grid coords.
> - It's easier to change `snapToCell()` to operate on one coordinate than return both. Have to change it manually, as it is getting messy with Gemini.
> - there is a bug in `snapToCell` it only rounds within 1 pixel no matter how big is the threshold.

***Prompt:***
Look at `snapToCell` function, it only snaps within 1 pixel no matter how big is the threshold. Fix it.

***Prompt:***
This is still incorrect. the difference between a coordinate and it's rounded value is still within 1 pixel.

***Prompt:***
The problem is still there. We want to round 27 to 25, with the threshold of 0.5 and the cellSize 16

***Prompt:***
We have to snap within half of the cell, which is 8 pixels. For example x=6 is snapped to x=0. x=22 is snapped to 24. Checking `Math.abs(position.x - Math.round(position.x))` is incorrect, as this difference is always within 1 pixel.

> [!NOTE]
>
> - Here I give up because Gemini is clearly unable to understand and fix the problem.
> - Multiple other tests had shown Gemini really struggles with this kind of problems.

***Prompt:***
Suggest optimization to this function.  It detects collisions of 4 corners of pacman with walls and creates false positives. Function:
<- code of canMove ->

> [!NOTE]
>
> - While suggestion to reduce 4 corner checks is valid. Optimization is buggy. Gemini wrongly implies there is a direction info in these 4 coordinates, while there is none and thus conditional checks are wrong.

***Prompt:***
If I've implemented snapping to the grid, do I need to check all 4 corners of Pacman for collisions? If I do, modify this `canMove()` collision checker.
<- code of canMove ->

***Answer:***

```markdown
Yes, even with snapping to the grid, it's generally recommended to check all 4 corners of Pacman for collisions. Here's why:

1. Floating-point Precision Errors:
2. Sub-cell Collisions:

Modified canMove function:
<- code of canMove ->
```

> [!NOTE]
>
> - Gemini insists on the same buggy modification to `canMove()`.
> - The problem with snapping all coordinates is, when changing direction we aren't longer collide with the wall as the coordinates are snapped back into the current empty cell.

***Prompt:***
Without adding snapping to the grid into `move()` method of Pacman, Pacman can't turn into some of the corridors. With added snapping, the coordinates that otherwise be inside the wall on a direction change are snapped back into the open cell creating a false positive directional change. Provide suggestions on how to fix the problem.

***Answer:***

```markdown
Here are a few approaches to fix this problem:

1. Pre-Turn Check:
<- code ->
2. Post-Turn Snap with Tolerance:
<- code ->
3. Directional Snapping:
<- code ->
```

> [!NOTE]
>
> - (1) doesn't solve the problem as without snapping and with 4 point check, to turn we'd have to have a perfect alignment of pacman with the corridor next to it. 1 point check brings us back to previous bugs.
> - (2) doesn't work either, as it always snaps
> - (3) a no go either
> - It's getting hard to make Gemini design a working approach with incremental small movements of Pacman together with the snapping to grid. Let's try something different.

## Step 17

**Problem:** The maze is drawn over white background, that is visually distracting. Needs to be changed to black.

***Prompt:***
How to change the background of an empty html page from white to black

***Answer:***

```markdown
There are two main ways to change the background of an empty HTML page from white to black:
1. Using CSS:
This is the most common and recommended approach. Here's how to do it.

<- code ->
```

## Step 18

**Problem:** It's time to host our Pacman game somewhere. Let's try Github pages.

***Prompt:***
Give me step by step instructions on how can I host our pacman game on github pages

> [!NOTE]
>
> - Gemini instructions + minor lookup of Github docs and it's live: [https://bryndin.github.io/ai-coded-pacman/](https://bryndin.github.io/ai-coded-pacman/)

## Step 19

**Problem:** Collisions and snapping is still broken.

***Prompt:***
Pacman move logic has a collision problem. Suggest code modifications to resolve them.
In the `move()` function below `desiredDirX` and `desiredDirY` are the new desired direction for Pacman, while `directionX` and `directionY` are the current movement direction,  each can take values of -1, 0, or 1. `canMove` function checks 4 corners of Pacman against the grid to know if there is a wall or open space.
<- code ->

> [!NOTE]
>
> - Gemini suggests pre-turn checks and making `canMove` check all 4 corners, that we already told it we do.

***Prompt:***
My code already implements Option 1 and Option 2, and the collision issue is still there. Modify code to implement Option 3.

> [!NOTE]
>
> - Option 3 does a while loop moving Pacman "slower" not to overstep the tern. "slower" mins taking 0.1 of a step. This can still skip some pixels and lead to a missed turn.

***Prompt:***
The snapTolerance can still be over 1 pixel in length and thus can overstep the exact location of a corridor. Why not make snapTolerance to be exactly 1 pixel?

***Answer:***

```markdown
You're right, setting snapTolerance to exactly 1 pixel can seem like a good solution to avoid overstepping the corridor boundaries. However, there are potential drawbacks to consider:

Grid Imperfections: Even with a perfect grid representation in your code, there might be slight rounding errors during calculations (especially when dealing with floating-point numbers) that could cause Pacman to miss the exact corridor center by 1 pixel. This can still lead to collisions or jittery movement.

Floating-Point Precision: Computers often represent numbers using floating-point arithmetic, which can introduce slight inaccuracies. Setting snapTolerance to 1 pixel might not guarantee perfect snapping due to these limitations.

Snapping Issues: With a 1-pixel tolerance, Pacman might get stuck in narrow corridors where the combined width of Pacman and the corridor walls is less than or equal to the sum of his size and the tolerance (e.g., Pacman size = 10 pixels, corridor width = 11 pixels, tolerance = 1 pixel). He wouldn't be able to move in either direction because snapping to the center would always cause a collision.

Alternatives to 1-Pixel Tolerance:

Lower Tolerance with Buffer: You can keep the tolerance slightly lower than 1 pixel (e.g., 0.9) to avoid overstepping corridor boundaries in most cases. Additionally, you can introduce a small buffer zone around corridor walls (e.g., 0.1 pixels) within which collisions are ignored. This allows for slight inaccuracies and smoother movement.

Raycasting: Implement a raycasting system to check for clear paths in the desired direction before attempting movement. This can provide more precise collision detection and avoid the need for snapping altogether.

Combined Approach: Consider a combination of pre-turn checks, a slightly lower tolerance for snapping, and a small buffer zone for smoother movement. This approach might offer a balance between accuracy and visual appeal.

Considerations:

Carefully test your chosen approach to ensure Pacman moves smoothly within corridors without getting stuck or exhibiting jittery behavior.
Adjust values like tolerance and buffer size based on your specific grid size, Pacman size, and desired movement feel.
Remember: There's no one-size-fits-all solution, and the best approach might depend on your game's specific requirements and desired gameplay experience.
```

> [!NOTE]
>
> - Putting ray tracing aside, we can try to eliminate floating points by working with integers only.

***Prompt:***
At what rate does p5js lib calls the `draw()` function?

> [!NOTE]
>
> - Gemini tells us p5lib tries to draw at 60 fps. That can drop with complex animation or slow machines.

***Prompt:***
Do we need the currentTime and deltaTime multipliers, given that p5lib tries to draw at 60 fps?

***Prompt:***
If we remove that logic, we should be able to solve the collision problem if our grid cell size in pixels is divisible by the value of `this.speed` variable in the pacman coordinates calculation below. Is it correct?

***Answer (shortened):***

>Yes, you're absolutely correct! Removing the currentTime and deltaTime multipliers and ensuring the grid cell size is divisible by the speed value can potentially solve the collision problem in certain scenarios.

> [!NOTE]
>
> - Lets leave the speed factor be divisible of the cell size for now. To keep it simple.

## Step 20

***Prompt:***
Improve the following code and print the improved version

***Answer:***

><- code (partial) ->
>
>Improvements made include:
>
>Constants are defined in uppercase to indicate that they are constants.
>Switch statement is used in keyPressed function for better readability.
>Code comments are added for clarity in certain sections.
>Minor formatting adjustments for consistency and readability.
>This revised version should be more organized, easier to read, and maintain.

> [!NOTE]
>
> - None of the LLMs where able to look at the file at github. Pasting the entire JS code only (partially) worked in ChatGPT, that was able to suggest a few minor improvements and printed the first part of the file back. So the other parts are probably were cut due to the token size.
> - Current code is 6,249 tokens (See [Online Tokenizer](https://platform.openai.com/tokenizer)).
> - Context size. The exact context size for each of the Gemini, ChatGPT and MS Copilot is hard to find. Rumors vary significantly, ranging from 4k tokens to 32k. With the output being as small as 2k.
> - ChatGPT 3.5 (input+output: 16k, output: 4k). We don't know if this is the model deployed, nor if there is a 4k pre message limit.
> - Given that returned code if often cut or the functions are replaced with stabs, we could be hitting that 4k token limit.
> - Llama3-70b-8192 on Groq seem to have output limit around 2k tokens.
> - Conclusion, LLMs have problems working with the code of 6k tokens. We may want to refactor the code to be more decoupled, then work on independent parts separately.

## Step 21

**Problem:** The grid is not associated with the starting positions of Pacman and ghosts. Better have a concept of a level.

***Prompt:***
Generate a Javascript class representing a Pacman Level, that has a 2D layout defining the walls, starting position of Pacman, and starting positions of Ghosts per each unique ghost.

***Prompt:***
Add validation logic to PacmanLevel layout coming as an argument to constructor.

## Step 22

**Problem:** Design rendering logic. Do we want to separate rendering from content? Make it less reliant on global variables.

***Prompt:***
For the game Pacman, I have entities: GameBoard, Level, Pacman, Ghost. Explain different ways to organize the rendering of these entities in Javascript. I use p5play.js lib.

***Answer (Gemini):***

>Here are different ways to organize the rendering of entities in your Pacman game using p5play.js:
>
>**1. Individual Render Functions:**
>
>**2. Entity Class with render method:**
>
>**3. Component-based System:**
>* Define separate components for rendering (e.g., Renderer component) and logic (e.g., Movement component).
>* Each entity can have multiple components attached.
>* Have a separate system responsible for iterating through entities and calling the `render` method of their attached Renderer component.
>
>This approach offers more flexibility and separation of concerns but might be overkill for a simple Pacman game.
>
>**Choosing the right approach:**
>
>* For a simple Pacman game, approach 1 or 2 is probably sufficient.
>* If your game becomes more complex with many different types of entities and behaviors, approach 3 might be beneficial.

***Answer (Llama3):***

>**1. Single render function**
>
>**2. Entity-specific render functions**
>
>**3. Use a rendering layer system**
>
>**4. Use a scene graph**
>
>Choose the approach that best fits your game's requirements and complexity. You can always mix and match these approaches to create a hybrid solution that works best for your game.

> [!NOTE]
>
> - Rendering layers and scene graphs is an overkill for Pacman.
> - Complex rendering component is an overkill too.
> - As Gemini said, either do separate rendering functions or make them class methods.
> - For simplicity, lets keep entity classes separated from rendering logic and use standalone functions.

## Step 23

**Problem:** Let's see what important entities are we missing.

***Prompt:*** What are the main Javascript classes needed for Pacman game?

***Answer (llama3):***
>Here are the main JavaScript classes needed to implement a Pac-Man game:
>
>1. **Game**: The main game class, responsible for initializing and managing the game state, including the game loop, scoring, and level management.
>2. **PacMan**: Represents the Pac-Man character, handling its movement, collision detection, and interactions with the maze and ghosts.
>3. **Ghost**: A base class for the four ghosts (Blinky, Pinky, Inky, and Clyde), managing their AI, movement, and interactions with Pac-Man.
>4. **Maze**: Represents the game board, handling the layout, wall collisions, and pellet placement.
>5. **Pellet**: Represents individual pellets, including their placement, scoring, and consumption by Pac-Man.
>6. **PowerPellet**: A subclass of Pellet, representing the power pellets that allow Pac-Man to eat ghosts.
>7. **Fruit**: Represents the bonus fruits that appear in the maze, providing extra points when eaten by Pac-Man.
>8. **Score**: Manages the scoring system, tracking Pac-Man's points, lives, and level progress.
>9. **Level**: Represents a single level, handling the maze layout, pellet placement, and ghost behavior.
>
>Optional classes:
>
>1. **SoundManager**: Handles sound effects and music for the game.
>2. **InputManager**: Manages user input, such as keyboard or touch events, to control Pac-Man's movement.
>3. **Graphics**: Responsible for rendering the game graphics, including the maze, characters, and UI elements.
>
>These classes can be organized into a more detailed hierarchy, and some classes might be merged or split depending on the specific implementation. However, this list provides a solid foundation for building a Pac-Man game in JavaScript.

## Step 24

**Problem:** Everything but Pacman and Ghosts operate on "position" structure. Refactor them to match.

> [!NOTE]
> Refactoring with LLMs is not worth the time. Have to do it by hand.

## Step 25

**Problem:** We need a `Game` class to control the entire game.

***Prompt:*** Describe the `Game` class.

***Answer: (Gemini)***

>The `Game` class acts as the central control unit for your Pacman game. Here's a breakdown of its functionalities:
>
>**Initialization:**
>
>* Sets up the game world: Creates instances of `Maze`, `Pacman`, `Ghost` (potentially multiple), `Pellet`, and other necessary objects.
>* Initializes game variables like score, lives, and level.
>* Loads game assets like images and sounds.
>
>**Game Loop:**
>
>*  The core function that continuously updates the game state.
>* Manages the flow of the game by calling methods on other classes like:
>    *  `Pacman.move()` to update Pacman's position based on user input.
>    *  `Ghost.update()` to handle ghost movement and AI logic.
>    *  `Maze.checkCollisions()` to detect collisions between Pacman, ghosts, pellets, and walls.
>* Updates the game state based on these interactions:
>    *  Increase score for eaten pellets.
>    *  Decrease lives on collision with a ghost in chase mode.
>    *  Switch ghost behavior to frightened mode when a power pellet is eaten.
>    *  Check for win/lose conditions (all pellets eaten, no lives left).
>
>**Other functionalities:**
>
>* Handles rendering the game: Might directly call drawing functions on the game objects or interact with a separate graphics class.
>* Manages game states: Pausing, ending the game, and potentially handling transitions between levels.
>* May handle user input: Capturing key presses to control Pacman's movement.

***Prompt:*** Provide Javascript code for the Game class.

***Prompt:*** Remove all the rendering logic from `Game` class, it will be placed into a separate set of functions that you don't have to show. Show the updated class.

***Prompt:***

1. Describe why you need `canvas` attribute, remove it if not needed.
2. move game loop logic into the `draw()` function of p5play.js library.

***Prompt:*** `Game` class must receive an array of levels, and have logic to switch to next level.

> [!NOTE]
> `Game` class is not finished. We preserved Pacman movement, but the rest of logic is a stub.

## Step 26

**Problem:** Detect collisions between Ghost and Pacman.

***Prompt:** You're developing a Pacman game. You have 2 classes: `Pacman` and `Ghost`. `Pacman` class has the attribute `position`, an object with the x,y coordinates of the upper left corner, e.g. `{x: 1, y: 2}`; and `size`. `Ghost` has similar attributes `position` and `pacmanPosition` for the ghost and the Pacman positions respectively; and attribute `size`. Write Javascript code to detect collision between ghost and Pacman.

> [!NOTE]
> Gemini provides a slightly better optimized code, comparing to Llama3-70b.

***Prompt:** In the Pacman game, you have 3 entities: Pacman, Ghost, and GameBoard, represented by Javascript classes. Which one is responsible for checking for a collision between Pacman and Ghost, and why?

> [!NOTE]
> Both LLMs suggest the `GameBoard` class to handle collision checks. Why?
>
> - Gemini: Centralized Knowledge, Separation of Concerns, Efficiency, Game State Management.
> - Llama3-70b: Single Responsibility Principle, Game Logic, Decoupling, Centralized Game State.

***Prompt:** Update the collision logic to have the collision function in the `Game` class, instead of the `Ghost` class. Generate Javascript code.

> [!NOTE]
> Gemini generates a slightly better code, factoring out the collision logic into a separate variable. When Llama3 injected the large `if` check inline.

## Step 27

**Problem:** When Ghost touches Pacman nothing happens. Implement the life loss functionality.

***Prompt:*** You are a game developer implementing a Pacman game. What happens when Ghost touches Pacman? Explain everything that is happening with the game state, animation, etc.

***Answer (MS Copilot):***
>When a Ghost touches Pacman in the game, several things happen:
>
>1. **Game State Update**: The game state changes to reflect that Pacman has been caught by a ghost. This could involve setting a variable like `pacmanCaught` to `true`.
>
>2. **Lives Update**: Pacman's lives count decreases by one. If Pacman has no lives left, the game state changes to `GameOver`.
>
>3. **Animation**: An animation plays to show Pacman being caught by the ghost. This could be Pacman flashing, changing color, or some other visual effect.
>
>4. **Sound Effects**: A sound effect plays to indicate that Pacman has been caught. This helps to alert the player to what has happened.
>
>5. **Score Update**: The player's score may be updated. Depending on the game rules, the score could decrease as a penalty for being caught, or it could stay the same.
>
>6. **Reset Positions**: After the catch animation and sound have played out, Pacman and the ghosts are usually reset to their starting positions, and play resumes.
>
>7. **Game Speed**: In some versions of the game, the speed of the ghosts relative to Pacman might increase each time Pacman is caught, making the game progressively harder.

> [!NOTE]
> While both Gemini and LLama3 have similar answers, the Llama3 `Score Reset: The score is reset to zero, and the game starts fresh.` part is incorrect. Microsoft Copilot and ChatGPT3.5 answers are also similar. They are more concise and listed by execution order, instead of grouping into State/Animation/Sound as the first two.

## Step 28

**Problem:** Game logic becomes complex, it's more transparent to operate based on a state machine.

***Prompt:*** You are game developer creating a classic Pacman game in Javascript. You have classes GameBoard, Pacman, Ghost.  Class GameBoard controls the game and operates on game states. List all the states for the GameBoard that are needed for the game to work.

***Answer (MS Copilot):***
>Sure, here are some of the potential states that the `GameBoard` class might need to manage in a classic Pacman game:
>
>1. **`Start`**: This is the initial state of the game. The game waits for the player to start the game.
>
>2. **`Running`**: This state indicates that the game is currently in progress. Pacman and the ghosts are moving around the board.
>
>3. **`Paused`**: In this state, the game is temporarily halted, usually due to player action. Pacman and the ghosts are not moving.
>
>4. **`PacmanCaught`**: This state is triggered when a ghost catches Pacman. It might initiate an animation or sound effect and lead to a decrease in Pacman's lives.
>
>5. **`LevelComplete`**: This state is triggered when all the dots on the board have been eaten by Pacman. The game might display a message or animation, then proceed to the next level.
>
>6. **`GameOver`**: This state is triggered when Pacman has no lives left. The game might display a "Game Over" message and wait for the player to start a new game.
>
>7. **`PowerUp`**: This state is triggered when Pacman eats a power pellet. The ghosts change their behavior (usually they run away from Pacman), and the game might display a different animation or sound effect.
>
>Remember, these are general states and can vary based on the specific implementation of the game. The key is to manage these states appropriately to ensure the game runs smoothly. Each state might also have associated actions that are triggered when entering or exiting the state. For example, when entering the `GameOver` state, the game might play a specific sound effect, display a message to the player, and update the high score list. When exiting the `GameOver` state (i.e., starting a new game), the game would reset all game variables to their initial values.

> [!NOTE]
> MS Copilot gave the best option and described it in the simplest terms. Gemini came close. Llama3 had extra steps, e.g. `WAITING_FOR_INPUT`, `ANIMATING` that aren't a good fit.

***Prompt:*** Create a finite state machine for the states you've provided.

> [!NOTE]
> MS Copilot has concise explanation. It even tried to draw the states in pseudo graphics, but hallucinated in state transitions. Gemini didn't draw, bet described it well, though the answer were harder to process.

***Answer (MS Copilot):***
>Sure, here's a simple representation of a finite state machine for the Pacman game:
>
>```plaintext
>+-----------+     +---------+     +--------+     +-------------+
>|           |     |         |     |        |     |             |
>|   Start   +-----> Running +-----> Paused +-----> PacmanCaught |
>|           |     |         |     |        |     |             |
>+-----+-----+     +----+----+     +---+----+     +------+------+
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      v                v              v                 v
>+-----+-----+     +----+----+     +---+----+     +------+------+
>|           |     |         |     |        |     |             |
>| GameOver  <-----+ Level   +<----+ PowerUp+<----+ PacmanCaught |
>|           |     | Complete|     |        |     |             |
>+-----------+     +---------+     +--------+     +-------------+
>```
>
>- **Start**: The initial state of the game. The game waits for the player to start the game.
>- **Running**: The game is currently in progress. Pacman and the ghosts are moving around the board.
>- **Paused**: The game is temporarily halted, usually due to player action. Pacman and the ghosts are not moving.
>- **PacmanCaught**: Triggered when a ghost catches Pacman. It might initiate an animation or sound effect and lead to a decrease in Pacman's lives.
>- **PowerUp**: Triggered when Pacman eats a power pellet. The ghosts change their behavior (usually they run away from Pacman), and the game might display a different animation or sound effect.
>- **LevelComplete**: Triggered when all the dots on the board have been eaten by Pacman. The game might display a message or animation, then proceed to the next level.
>- **GameOver**: Triggered when Pacman has no lives left. The game might display a "Game Over" message and wait for the player to start a new game.
>
>Each arrow represents a transition from one state to another. The direction of the arrow indicates the direction of the transition. For example, the game can go from the `Start` state to the `Running` state, but not the other way around. The game can transition from almost any state to the `GameOver` state, reflecting the fact that the game can end at any time if Pacman runs out of lives. Note that this is a simplified model and actual implementation might have more states and transitions.

***Answer (Gemini):***
>Here's a finite state machine representation for the Pacman game states:
>
>**States:**
>
>* Setup
>* Running
>* Pacman Dead
>* Level Complete
>* Paused
>* Game Over
>
>**Transitions:**
>
>* Setup -> Running: This happens when the initial game board is created and ready for gameplay.
>* Running -> Pacman Dead: This occurs when Pacman collides with a ghost.
>* Running -> Level Complete: This triggers when Pacman eats all the dots on the current level.
>* Running -> Paused: This happens when the user pauses the game.
>* Paused -> Running: This occurs when the user resumes the game from a paused state.
>* Running -> Power Pellet Active (Sub-state): This is a temporary transition within Running when Pacman eats a power pellet.
>* Power Pellet Active -> Running: This transition happens when the power pellet effect wears off.
>* Running -> Ghost Frightened (Sub-state): This is another temporary transition within Running when Pacman eats a power pellet, making ghosts vulnerable.
>* Ghost Frightened -> Running: This occurs when the ghost vulnerability period ends.
>* Level Complete -> Running (Optional): This could be used to restart the current level.
>* Level Complete -> Next Level (Optional): This would transition to a new level if available.
>* Pacman Dead -> Game Over (Optional): This happens if the player has no more lives left.
>* Pacman Dead -> Running (Optional): This could be used to restart the current level with a life cost.
>
>**Events:**
>
>* Game Start: Triggers the transition from Setup to Running.
>* User Input (Movement, Pause): Triggers transitions based on player actions.
>* Collision (Pacman-Ghost): Triggers the transition from Running to Pacman Dead.
>* Dot Eaten (Last Dot): Triggers the transition from Running to Level Complete.
>* Power Pellet Eaten: Triggers the temporary transition to Power Pellet Active within Running.
>* Power Pellet Effect Ends: Triggers the transition back to Running from Power Pellet Active.
>* Ghost Eaten (By Pacman): Triggers the temporary transition to Ghost Frightened within Running.
>* Ghost Vulnerability Ends: Triggers the transition back to Running from Ghost Frightened.
>* Level Completion Logic: Determines if the game progresses to the next level or restarts the current one.
>* Game Over Condition (Lives Depleted): Triggers the transition from Pacman Dead (or any state) to Game Over.
>
>**Notes:**
>
>* This is a simplified FSM, and additional states or transitions might be needed depending on the complexity of your game.
>* The optional transitions allow for design choices on how the game handles restarts, level progression, and handling Pacman deaths.
>* Sub-states like Power Pellet Active and Ghost Frightened can be implemented within the Running state for temporary behavior changes.

***Prompt:*** Create a finite state machine for the states you've provided.

> [!NOTE]
> MS Copilot has concise explanation. It even tried to draw the states in pseudo graphics, but hallucinated in state transitions. Gemini didn't draw, bet described it well, though the answer were harder to process.

***Prompt:*** Generate Javascript code for the GameBoard class that contains all these states. Add logic to check the state and execute game logic based on that state.

> [!NOTE]
> We use a mix of code from MS Copilot and Gemini. Gemini generated a dedicated static object listing all state constants, while Copilot didn't. But Copilot generates chunks of game logic for each state that we will reuse. Unrelated, Copilot uses too much space between code lines visually, that makes it harder to read compared to Gemini.

## Step 29

**Problem:** Number of lives and score aren't displayed.

***Prompt:*** You're developing the game Pacman in Javascript. Generate code that uses p5play.js lib to display the current score and Pacman lives on the canvas.

## Step 30

**Problem:** Game have no pellets and thus no winning.

***Prompt:*** You are game developer creating a classic Pacman game in Javascript. You have classes GameBoard, Pacman, Ghost. Explain how pellets have to be implemented there.

***Answer (Gemini):***
>There are a few ways to implement pellets in your classic Pacman game using Javascript and the classes you mentioned:
>
>**1. Multi-dimensional Array in GameBoard:**
>
>**2. Separate Pellet Class:**
>
>**3. Combining both approaches:**
>
>* Use a 2D array for the overall layout in `GameBoard`.
>* Within the array elements representing empty spaces, store references to `Pellet` objects (if any).
>* This allows flexibility in defining different types of pellets and simplifies adding/removing them during gameplay.
>
>**Pacman and Pellet Interaction:**
>
>* In the `Pacman` class, implement a collision detection method that checks if Pacman's position overlaps with a pellet's position (using either array index or object reference).
>* Upon collision:
>    * Remove the pellet from the board (array or object list).
>    * Update the game score in `GameBoard`.
>    * Play a sound effect (optional).
>
>**Remember:**
>
>* Whichever method you choose, ensure efficient collision detection to optimize game performance.
>* Consider adding a property to the `Pellet` class to track if it's been eaten, allowing removal from the board only once.
>
>These are some ways to implement pellets in your Pacman game. Choose the approach that best suits your project structure and coding style.

***Prompt:***
You're developing the game Pacman in Javascript. You have a class `Level` provided below. `layout` argument is a 2D array describing the level, pellets are represented by "." character there. Modify class `Level` to parse the layout, count and store the number of pellets. Provide a function or a method to remove pellet from the provided coordinates.

class Level {
  constructor(layout) {
    this.layout = layout;
    this.height = this.layout.length;
    this.width = this.layout[0].length;
  }
}

***Prompt:*** Modify `removePellet` to throw an exception if x and y are outside of the layout size.

***Prompt:*** Using Javascript lib p5play.js generate code to draw a pellet from the Pacman game.

***Prompt:*** In the `draw()` function, replace the `if` check with the switch/case logic.

> [!NOTE]
> Gemini did a good job providing code. For the level layout to save time we updated it manually.

***Prompt:*** You're developing the game Pacman in Javascript. You have a class `Game` representing main game logic. Function `main()` is the main game loop. The state `Game.states.RUNNING` means Pacman is moving. `level` is an instance of class `Level`. `layout` is a 2D array representing the level, where "." character is a pellet.
To the code below add functionality of Pacman eating pellets and thus increasing the score in `score` attribute.

class Level {
  constructor(layout, pacmanStart, ghostStarts) {
    this.layout = layout;
    this.pellets = this.countPellets();
  }
}

class Game {
  constructor(level) {
    this.level = level;
    this.score = 0;
    this.state = Game.states.RUNNING;
    this.pacman = new Pacman(level.pacmanStart, CELL_SIZE, 2);
  }

  main() {
    switch (this.state) {
      case Game.states.RUNNING:
        this.pacman.move();

        if (this.checkPacmanGhostCollision()) {
          this.setState(Game.states.PACMAN_DEAD);
        }

        if (this.isLevelComplete()) {
          this.setLevel(this.currentLevelIndex + 1);
        }

        if (this.checkGameCompletion()) {
          this.setState(Game.states.GAME_OVER);
        }

        break;
    }
  }
}

***Prompt:*** Why does `checkPelletCollision` modify the state of the Game, being a "check" method?

***Prompt:*** Use Option 2, where logic is in the `main()` function. There is a problem with `this.level.layout[this.pacman.y][this.pacman.x]` code. `layout` uses layout local coordinates, while `pacman` uses canvas coordinates. Fix it.

***Answer: (shortened)***

>```javascript
>  const cellX = Math.floor(this.pacman.x / CELL_SIZE);
>  const cellY = Math.floor(this.pacman.y / CELL_SIZE);
>  if (this.level.layout[cellY][cellX] === ".") {
>    this.level.layout[cellY][cellX] = " ";
>    this.score += 10;
>```

***Prompt:*** There still could be a problem related to `Math.floor`. Most of the Pacman can be already located in the next cell, but the top left corner of Pacman (`this.pacman.x` and `this.pacman.y`) can be still in the previous cell.

***Answer: (shortened)***
>You're absolutely right. Using `Math.floor` alone might lead to situations where Pacman is mostly in the next cell but its top left corner is still considered in the previous cell, causing missed pellet detections. Here are two approaches to address this:
>
>**Approach 1: Check for overlapping with both current and next cell**
>
>**Approach 2: Use a threshold for cell occupancy**
>
>**Choosing the Approach:**
>
>* Approach 1 might be more complex but offers more precise detection, especially for faster Pacman speeds.
>* Approach 2 is simpler but relies on a chosen threshold value, which might require some experimentation for optimal results.

***Prompt:*** 
Going with Approach 1, would it be better to check 4 cells instead of 2? The current one plus the one to the left, the one below and the one below to the left?

***Answer(shortened):***
>While checking four cells (current, next in movement direction, and diagonally below/left) might seem more comprehensive for pellet detection, it can introduce unnecessary complexity and potential issues. Here's why:

***Prompt:***
Approach 1 can make Pacman prematurely eat a pellet in the next cell.  Why not use the collision check instead? We can compute the sprite size for the pellet in the canvas coordinates.

***Answer(shortened):***
>You're right, Approach 1 with just checking the next cell based on movement direction can lead to premature pellet eating. Here's how we can leverage the collision detection logic to achieve more accurate pellet consumption using the pellet sprite size:
>
>**1. Define Pellet Information:**
>
>* Introduce a new property in the `Level` class to store the pellet sprite size:
>
>**2. Modify `main()` Function:**
>
>* Instead of checking the next cell based on direction, use the collision detection logic to check for overlap with the current cell's pellet:
>
>**Explanation:**
>
>1. We calculate the exact coordinates of the pellet's bounding box in canvas space based on its position in the level layout (`cellX`, `cellY`) and the defined `pelletSize`.
>2. We call the `isColliding` function (assuming you have one for collision detection) to check if Pacman's sprite overlaps with the calculated pellet bounding box. 
>3. If there's a collision and the tile is a ".", we remove the pellet from the layout and update the score.
>
>This approach leverages the existing collision detection logic for more accurate pellet eating detection based on the actual sprite sizes of Pacman and the pellet.
>
>**Note:**
>
>* Ensure your `isColliding` function can handle both rectangle-to-rectangle and circle-to-rectangle collisions, depending on how you represent Pacman and the pellet sprites.

***Prompt:***
This again has the problem when most of the Pacman sprite is in the next cell, touching the next pellet sprite that this logic won't detect.

***Answer (shortened):***
>You're absolutely right. The previous approach based solely on the pellet's bounding box might still miss pellets when Pacman is mostly in the next cell. Here's a refined solution that combines collision detection and a threshold for Pacman's position within a cell:
>
>**1. Define Threshold and Pellet Information:**
>
>* Introduce a `cellOccupancyThreshold` property in the `Game` class:
>
>**2. Modify `main()` Function:**
>
>* Combine collision detection with the threshold check:
>
>**Explanation:**
>
>1. We calculate the `isPastThreshold` flag to check if Pacman's X position is beyond the threshold point within the current cell.
>2. The pellet is considered eaten if:
>    * The tile is a "." (pellet) and
>    * EITHER Pacman is past the threshold within the current cell (ensuring it's not just touching the edge) OR
>    * There's a collision between Pacman and the pellet's bounding box.
>
>This approach combines the strengths of both previous solutions:
>
>* It leverages collision detection for more precise handling of sprite overlaps.
>* It uses the `cellOccupancyThreshold` to ensure Pacman doesn't eat a pellet in the next cell too early.
>
>**Adjusting the Threshold:**
>
>The `cellOccupancyThreshold` value impacts how deep Pacman needs to be within a cell to be considered occupying it for pellet consumption. Adjust this value based on your desired behavior and pellet size. 
>
>* A higher threshold ensures Pacman is further into the current cell before eating a pellet, potentially reducing the feeling of "premature" eating.
>* A lower threshold allows Pacman to eat pellets slightly earlier as it enters a cell.
>
>**Testing and Refinement:**
>
>Test your game with different threshold values to find the sweet spot that balances responsiveness and pellet eating accuracy for your specific game design. Remember, the ideal value might depend on factors like Pacman's speed and pellet size.

***Prompt:***
This introduces a magic number for a threshold that could lead to some hidden bugs. Why not check the 4 neighboring pellets and do a collision check with all 4?

***Answer (shortened):***
>You're right, using a magic number for the threshold might not be ideal and could lead to unexpected behavior in certain scenarios. Here's why checking all four neighboring pellets with collision detection can be a viable solution, with some considerations:
>
>**Benefits:**
>
>* **Reduced reliance on magic numbers:** By checking all four neighbors, we eliminate the need for a specific threshold value, potentially improving code maintainability and reducing the likelihood of hidden bugs related to the threshold.
>* **More comprehensive detection:** Checking all four neighbors ensures Pacman can eat pellets even if it's positioned diagonally between cells, offering a more complete solution.
>
>**Drawbacks:**
>
>* **Increased complexity:**  Checking four pellets with collision detection requires more calculations compared to checking the current cell and potentially the next one in movement direction. This might not be a significant performance hit for a simple Pacman game, but it's a factor to consider, especially for larger or more complex games.
>* **Potential for over-detection:** Depending on the implementation of the collision detection and pellet/Pacman size, there's a slight chance of Pacman eating pellets it shouldn't reach if it's perfectly positioned between cells.
>
>**Implementation:**
>
>Here's how you can implement checking all four neighboring pellets: ...
>
>**Explanation:**
>
>1. We define additional checks for the left, right, and top neighboring pellets based on their calculated bounding boxes.
>2. The `isPelletEaten` flag is set to `true` if any of the collision checks with the neighboring pellets return `true`.
>3. We only update the layout and score if there's a collision and the corresponding tile in the layout is a "." (pellet).
>
>**Choosing the Approach:**
>
>The decision between checking four neighbors with collision detection and a threshold-based approach depends on your game's priorities. 
>
>* If you prioritize simplicity and reducing magic numbers, checking four neighbors might be a good choice. Just be aware of the potential for slight over-detection in some scenarios.
>* If performance is a concern and you want a more precise control over Pacman's pellet eating behavior, a refined threshold-based approach with well-tested threshold values might be preferable.
>
>Ultimately, test both approaches in your game and see what works best for your specific design goals and desired level of pellet consumption accuracy.

***Prompt:***
This code will make Pacman eat at most one pellet, while Pacman sprite might touch several. Modify the code that if Pacman collides with several pellet sprites, each of them is removed from the level layout and increase the score.

***Prompt:***
You get cell coordinates from the Pacman canvas coordinates, `cellX` and `cellY`. Check that cell and the cells to the right, down, and right down, if any of them have a pellet, compute the sprite box for that pellet and use it to check for collision with Pacman.

> [!NOTE]
> This is where Gemini starts generating crazy code. Lets start over.


You're developing the game Pacman in Javascript. You have class `Level` with an attribute `layout` being a 2D array representing the level. "." character in the array cell is a pellet.
Class `Pacman` has attribute `position` that holds x,y coordinates of the top left sprite corner in canvas space.
Class `Game` contains a method `main()` responsible for the game logic.

After `this.pacman.move();` code add logic that checks for Pacman collision with pellets in four neighboring cells: current, one to the right, one below, one below to the right. If there is a pellet in a cell, compute its collision box in convas coordinates and check against collision with Pacman using `checkForOverlap` function. If there is a collision, increase the game score and remove the pellet from the layout via `removePellet` function.

```javascript
class Level {
  constructor(layout, pacmanStart, ghostStarts) {
    this.layout = layout;
    this.pellets = this.countPellets();
  }

  removePellet(x, y) {
    // this function removes pellet from the layout
  }
}

class Pacman {
  constructor(size) {
    this.position = {x: 1, y:10};
    this.size = size;
  }
}

class Game {
  constructor(level) {
    this.level = level;
    this.score = 0;
    this.pacman = new Pacman(level.pacmanStart, CELL_SIZE, 2);
  }

  main() {
    this.pacman.move();

    // here add the needed logic
  }
}

function checkForOverlap(obj1Position, obj2Position, obj1Size, obj2Size) {
  return (
    (obj1Position.x < obj2Position.x + obj2Size && obj1Position.x + obj1Size > obj2Position.x) &&
    (obj1Position.y < obj2Position.y + obj2Size && obj1Position.y + obj1Size > obj2Position.y)
  );
}
```

> [!NOTE]
> Both Gemini and Copilot did an ok-ish job with the code this time, though using different approaches for iteration. BUT both use canvas coordinates in cell calculations, when they can simply add +1 to the level coordinated.

***Prompt:***
You use canvas coordinates to calculate cell coordinates on each iteration. Why not to calculate it once, then next cell in the layout coordinates will be just +1.

***Prompt:***
Do you need to check your cell x and y are within the layout limits?

> [!NOTE]
> Copilot added the check, yet it didn't figure out `x >= 0` one is redundant. Gemini claimed their code is alright, providing 2 points why. While one is based on JS voodoo and can hold, the other about throwing an exception is incorrect. We want to check, not to raise an exception to player.

***Prompt:***
Write a function in Javascript to convert an array of the form `["#..", "#.#"]` into array `["#", ".", "."], ["#", ".", "#"]`

## Step 31

**Problem:** Code uses hardcoded level elements, e.g. "#", ".". Use constants instead.

> [!NOTE]
> This is a simple refactoring, that is not worse dealing with complex LLM prompts.

## Step 32

**Problem:** Level layout and related information takes screen space and complicates working with code. Also it won't scale well adding more levels. Move it into a dedicated file.

***Prompt:***
In a Javascript project implementing the game Pacman, how to define levels in separate files, to be read from the main logic? Provide code example.

> [!NOTE]
> After dozens of tries with both Gemini and Copilot we encountered all possible hallucinations related to async processing, e.g.
>
> - (Copilot): `Promise.all(promises) maintains the order of the results based on the order of the promises, not the order of resolution.`
> - (Gemini): `No, Promise.all(promises)  does not maintain the order of the results based on the order the promises were added to the array. It resolves with an array containing the results of the fulfilled promises in the order they resolved, not the order they were created in.`
>
> Gemini constantly hallucinates about `async`, e.g.
>
> - skipping `async` declaration while using `await`.
> - seeing `async` where there is non declared.
>
> We really struggled with both LLMs and had a hard time to get a bug free code.

***Prompt:***
Generate javascript code that extracts the file name from a file path, e.g.
path: `levels/1.json` answer: `1`

***Prompt:***
in javascript how to convert "1" (char) into 1 (int)?

***Answer:***
>p5play.js itself doesn't provide a direct way to stop the game entirely upon an exception. However, you can achieve a similar effect using a combination of error handling and potentially modifying your code structure. Here are two approaches:
>
>**1. Throwing an Error from Within Your Code:**
>
>**2. Conditional Execution based on Successful Preloading:**
>
>**Choosing the Approach:**
>
>* Throwing an error is a simpler approach for critical errors that prevent the game from functioning correctly.
>* Conditional execution offers more flexibility for handling specific preload failures and providing alternative behavior (e.g., displaying an error message).
>
>Consider the nature of potential errors in your game and choose the approach that best suits your needs.
>
>**Additional Tips:**
>
>* You can use a similar approach to handle errors during the game loop (`draw` function) itself. If a critical error occurs during gameplay, throw an error or set `gameRunning` to `false` to stop the game.
>* Consider using a global error handler using `window.onerror` to catch any unhandled errors that might occur during the game. This can provide a more robust error handling mechanism.

***Prompt:***
You are developing a Pacman game in Javascript. You code layout consists of files
level.js declares class Level with an attribute layout.
pacman.js contains an array of all instances of levels.
levels is a directory holding javascript files containing data for each level, e.g. the level layout.
levels/1.js, levels/2.js files etc. instantiate class Level defined in level.js and make it available for the pacman.js file.
Generate code representing the above using ES6 syntax.

> [!NOTE]
>
> - We don't want to convert Pacman into an async app. Async fetching JSON blobs isn't an option.
> - Doing sync http requests don't look exciting either.
> - Let's use code imports instead.

***Prompt:***
You are developing a Pacman game in Javascript. You code layout consists of files
  - `level.js` declares class `Level` with an attribute `layout`.
  - `pacman.js` contains an array of all instances of levels.
  - `levels` is a directory holding javascript files containing data for each level, e.g. the level layout.
  - `levels/1.js`, `levels/2.js` files etc. instantiate class Level defined in `level.js` and make it available for the `pacman.js` file.
Generate code representing the above using ES6 syntax.

***Prompt:***
Explain export default { layout }; part, why not `export default layout;

***Prompt:***
Why am I getting "Cannot use import statement outside a module" error about pacman.js?

***Answer (shortened):***
>The error "Cannot use import statement outside a module" arises because you're trying to use `import` statements in a script that isn't treated as a module by your browser or environment.  Here's why and how to fix it:
>
>**Solutions:**
>
>1. **Use a Module Loader (e.g., Webpack, Parcel)**
>
>2. **Set the `type` Attribute in `<script>` Tags**
>
>* **For Larger Projects:**  Module loaders (Webpack, Parcel) are highly recommended for larger projects because they offer more control and features for managing dependencies.
>* **For Smaller Projects or Prototypes:** The `type="module"` attribute is a simpler way to get started.

***Prompt:***
Content of file `1.js`:
```
const levelName = "Level 1";
const difficulty = "Easy";
export default { levelName, difficulty };
```

Content of file `2.js`:
```
const levelName = "Level 2";
const difficulty = "Hard";
export default { levelName, difficulty };
```

Give me an example on how to import all these variables in file `pacman.js`. If name clashes is a problem, suggest a solution.

***Answer (shortened):***
>You're right, name clashes are a problem when importing from multiple files with the same variable names. Here's how to handle this and a couple of solutions:
>
>**Direct Import with Renaming**
>
>
>**Importing into Objects (Namespaces)**

***Prompt:***
`pacman.js` contains functions `setup()` and `draw()` that are called by p5play.js lib.
After adding `type="module"` in front of `src="pacman.js"` in `index.html` these functions are no longer being called by the p5play lib. Why and how to fix it?

***Answer (Gemini):***
>The issue arises because adding `type="module"` in front of `src="pacman.js"` in `index.html` changes how the script is loaded. Here's the breakdown:
>
>Here are two ways to fix this:
>
>1. **Export Functions from pacman.js:**
>
>2. **Use the `window` Object:**

***Answer (Copilot):***
>
>```javascript
>// Add setup and draw to the global scope
>window.setup = setup;
>window.draw = draw;
>```

> [!NOTE]
>
> - Neither of 2 solutions from Gemini worked.
> - Copilots solution did work.

## Step 33

**Problem:** Move Renderer class into a separate file.

## Step 34

**Problem:** Factor out the rest of classes into separate files.

## Step 35

**Problem:** Ghosts must be able to move not only to empty space, but any space that is not a wall.

***Prompt:***
Does Javascript havea concept of set, a data structure to quickly lookup at?

## Step 36

**Problem:** Ghosts navigation is broken.

***Prompt:***
You are developing a Pacman game in Javascript. You have class `Ghost` listed below and variable `layout` that is a 2D array of the level, where the wall is defined by the constant `WALL`. Ghost has a method `move(layout, targetPosition)` with arguments of current level layout and the position of Pacman to go to, `targetPosition` is an object with x,y coordinates, e.g. `{x: 1, y: 4}`.
Ghost moves in canvas coordinates. Size of one level layout cell is stored in `CELL_SIZE` constant.

Generate code that finds an optimal path in the level maze defined by `layout` array and moves the ghost towards the given `targePosition` using the `speed` attribute.

const CELL_SIZE = 16;

class Ghost {
    constructor(startPositionInCellCoordinates) {
        this.position = { x: startPosition.x * CELL_SIZE, y: startPosition.y * CELL_SIZE };;
        this.size = CELL_SIZE;
        this.speed = 2;
    }

    move(layout, targetPosition) {
        // TODO generate movement logic based on the movement speed
    }
}

***Prompt:***
This is great, the only problem is  `this.position` is a coordinate of the top left corner, not the center of the ghost.  Modify logic accordingly.

***Prompt:***
For Pacman game is it better to operate with the sprite center or a top-left corner of the sprite for  pacman and ghost positions

***Answer (Gemini 1.5 Pro):***
>For a Pacman game, it's generally better to **operate with the center of the sprite** for both Pacman and ghost positions. Here's why:
>
>* **Collision Detection:** Collision detection becomes more intuitive and accurate when working with centers. You can easily check if the distance between the centers of two sprites is less than the sum of their radii to determine a collision.
>* **Movement Logic:**  When moving characters, thinking about them moving from center to center of grid cells makes the logic more straightforward. You're aiming for specific points on the grid rather than dealing with corner alignments.
>* **Rotation:** If you plan to implement any rotation for Pacman or the ghosts, rotating around the center is much simpler than rotating around a corner.
>
>**While using the top-left corner might seem easier at first:**
>
>* It often leads to more complex calculations when determining cell positions, especially when considering the size of the sprite.
>* Collision detection becomes less intuitive, requiring adjustments based on sprite dimensions.
>
>**In summary:**  Center-based coordinates provide a more intuitive and convenient system for sprite positioning, movement, and collision detection in a Pacman game, making your development process smoother. 

> [!NOTE]
>
> Gemini 1.5 Pro is very impressive. It generated a very clean and well written code for the ghost AI that worked right away.
> The suggestion to use center of the cell instead of the top-left corner also makes sense.

## Step 37

**Problem:** Ghosts rendering logic is broken, see if it can be fixed.

***Prompt:***
Generate code for drawing a Pacman ghost in JS using p5.js game lib. The function signature: `drawGhost(pos, size, color)` where `pos` are the coordinates of the sprite center in the form `{x: 1, y: 4}`, `size` is the sprite size and color is the ghost color.

***Prompt:***
In your `drawGhost` code only the eyes are drawn, why?

***Answer (Gemini 1.5 Pro, shortened)***
>You are absolutely correct! There was an error in the previous `drawGhost` function. The `arc()` function was only drawing the eyes because I accidentally set the start and end angles to `0` and `PI`, which creates a semicircle representing the eyes.

***Prompt:***
Isn't it the same code as before?

***Answer (Gemini 1.5 Pro, shortened)***
>You are absolutely right!  I apologize for the mistake. The code I provided in the previous response was indeed **exactly the same as the original incorrect code**.
>
>I am still under development and learning to perform these tasks accurately. It seems I made a copy-paste error and did not properly implement the correction I described.
>
>I am working on improving my ability to generate and verify code accurately. Thank you for pointing out the error!

***Prompt:***
in p5.js lib, the function `arc` takes radians or degrees?  What setting defines the units used?

> [!NOTE]
>
> While Gemini generates code in radians, for some reason the p5.js defaulted to degrees. Had to explicitly switch to radians.

***Prompt:***
Explain what is supposed to be drawn by `drawGhost` logic.  Is `arc` supposed to draw a lower semi-circle? Why `vertex` draw a shape resembling the upper semicircle?

***Prompt:***
Is the vertex calculation correct?  It doesn't look like a skirt.

> [!NOTE]
>
> Gemini 1.5 Pro struggles to create proper logic for drawing a ghost. It's not clear why it suggests drawing a bottom semicircle, for the ghosts head when it have to be the top. It can't get the proper trigonometric functions to draw the wavy skirt in several attempts.
> For now we disable the skirt logic and replace it with a rectangle.

## Step 38

**Problem:** Ghosts rendering logic is broken, see if it can be fixed.

> [!NOTE]
> We fixed the drawing logic by hand as LLMs kept hallucinating with trig functions.

## Step 39

**Problem:** Render Pacman with the mouth open.

***Prompt (Gemini 1.5 Pro):***
Using p5.js lib generate code to draw Pacman of size `size`, at position x,y and heading the direction `dir`.

***Prompt (Gemini 1.5 Pro):***
Can you rewrite `drawPacman` using `rotate` function from p5.js?

> [!NOTE]
> While generated code looked reasonable, some p5.js defaults on angles got in the way. Rotating image is easier to handle.
> Other than that, good job Gemini.

## Step 40

**Problem:** Inconsistent handling of sprites: Ghost position is in the center, Pacman etc are the top-left corner. Need to converge.

> [!NOTE]
> Simple refactoring

## Step 41

**Problem:** We need 4 ghosts with different personalities.

***Prompt (Gemini 1.5 Pro):***
Define the AI behavior of ghosts in the classical Pacman game.

***Answer (Gemini 1.5 Pro):***
>The ghosts in the classic Pac-Man game don't use Artificial Intelligence in the modern sense. They operate on a system of pre-programmed behaviors and simple algorithms, often referred to as Finite State Machines. 
>
>Here's how their "AI" works:
>
>* **Scatter Mode:** Each ghost has a designated corner of the maze they head towards in this mode. This creates the illusion of random movement.
>* **Chase Mode:** Ghosts switch to aggressively pursuing Pac-Man, each using a different strategy:
>    * **Blinky (Red):** Directly targets Pac-Man's current position.
>    * **Pinky (Pink):** Tries to ambush Pac-Man by aiming 4 tiles ahead of his direction.
>    * **Inky (Cyan):** Uses a more complex strategy based on both Pac-Man's position and Blinky's position.
>    * **Clyde (Orange):** Targets Pac-Man directly when far away but switches to scatter mode when getting too close, creating erratic behavior.
>* **Frightened Mode:** When Pac-Man eats a Power Pellet, ghosts turn blue, slow down, and reverse their movement direction. Pac-Man can eat them in this state.
>* **Eaten Mode:** After being eaten, ghosts return to the center box, vulnerable and regenerating before rejoining the chase.

***Prompt:***

1. Explain what causes the transition between Scatter and Chase modes. 2. Explain how corners are selected per ghost. 3. Explain Clyde's strategy in more detail.

***Answer (Gemini 1.5 Pro):***
>Here's a breakdown of the ghost behavior you asked about:
>
>1. **Transition between Scatter and Chase Modes:**
>
>   The transitions between Scatter and Chase modes are based on timers.  The game cycles through pre-defined periods of Scatter and Chase modes:
>
>   * **Level 1:** 7 seconds Scatter, 20 seconds Chase, 7 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, remaining time Chase.
>   * **Levels 2-4:** 7 seconds Scatter, 20 seconds Chase, 7 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 1033 seconds Chase, 1/60 second Scatter, remaining time Chase.
>   * **Level 5 onward:** 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 1037 seconds Chase, 1/60 second Scatter, remaining time Chase.
>
>2. **Corner Selection per Ghost:**
>
>   Each ghost has a designated "home corner" they target during Scatter mode:
>
>   * **Blinky (Red):** Top right corner
>   * **Pinky (Pink):** Top left corner
>   * **Inky (Cyan):** Bottom right corner
>   * **Clyde (Orange):** Bottom left corner
>
>3. **Clyde's Strategy in Detail:**
>
>   Clyde is known for his seemingly erratic behavior, which stems from a unique chase strategy:
>
>   * **Distance-Based Switching:** Clyde targets Pac-Man's current position directly when he is *further* than 8 tiles away. 
>   * **Scatter Mode Trigger:** However, when Clyde gets *within* 8 tiles of Pac-Man, he switches to his designated Scatter mode behavior (heading for the bottom left corner).
>
>   This creates the illusion that Clyde is "shy" or "stupid" as he frequently abandons direct pursuit to retreat to his corner. In reality, this strategy makes him unpredictable and can catch players off guard, especially when navigating tight spaces where Clyde can suddenly shift from chasing to retreating.

***Prompt:***
Generate Javascript code defining these 4 ghosts and their chase behavior.

***Prompt:***
Update the code to use the function `findPath(currentPosition, targetPosition)`. This function returns a path from `currentPosition` to `targetPosition`, where these positions are in the level cell coordinates.

***Prompt:***
Give code for `chase()` function for Blinky.

***Prompt:***
Ghost class is unaware of "game" class. Class Game can access Ghost class but not vice versa.  Update the logic accordingly.

***Prompt:***
Explain the logic in `scatter()`. Is it correct?

***Answer (Gemini 1.5 Pro, shortened):***
>The condition `this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y` checks if the ghost has reached the *exact* center of its scatter target cell. However, due to the discrete movement of the ghost (moving one cell at a time), it's highly unlikely that the ghost will land precisely at the center. This means the `findPath` function might not be called again, leaving the ghost stuck even if it's very close to its target.

***Prompt:***
In this condition `if (this.path.length === 0 || this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y)` should the coordinates be not equal,  instead of equal?

***Answer (Gemini 1.5 Pro):***
>You are absolutely right! In the original condition:
>
>```javascript
>if (this.path.length === 0 || this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y) 
>```
>
>The logic is incorrect. The condition should check if the ghost's position is **not equal** to the scatter target coordinates. 
>
>Here's the corrected condition:
>
>```javascript
>if (this.path.length === 0 || this.position.x !== this.scatterTarget.x || this.position.y !== this.scatterTarget.y) 
>```
>
>**Explanation:**
>
>- We want to calculate a new path if either:
>    - The ghost has no current path (`this.path.length === 0`).
>    - The ghost's current position is **not** the same as its scatter target position (`this.position.x !== this.scatterTarget.x` **or** `this.position.y !== this.scatterTarget.y`).
>
>Using the **not equal** (`!==`) operator ensures that `findPath()` is called when the ghost needs to move towards its scatter target.
>
>The corrected logic makes much more sense! Thanks for pointing out the error.

***Prompt:***
Wouldn't we want to calculate the new path when the path is empty and ghosts aren't in the scattering spot?

***Answer(Gemini 1.5 Pro):***
>You are absolutely correct! We need to calculate a new path when both of these conditions are true:
>
>1. **The path is empty (`this.path.length === 0`):**  This means the ghost has either completed its previous path or is starting its movement.
>2. **The ghost is not near its scatter target (`!this.isNearTarget(this.scatterTarget)`):** This ensures that we don't recalculate a path if the ghost is already at (or very close to) its destination.
>
>Therefore, the correct condition for calling `findPath()` in the `scatter()` method is:
>
>```javascript
>if (this.path.length === 0 && !this.isNearTarget(this.scatterTarget)) {
>    this.path = findPath(this.position, this.scatterTarget);
>}
>```
>
>We need to use the logical **AND** operator (`&&`) to combine the two conditions. `findPath()` will only be executed if **both** conditions are true.
>
>Thank you for pointing out this crucial logical error. You've helped refine the code to be more accurate and efficient! 

> [!NOTE]
>
> - It does look like Gemini Pro have hard time to reason with math logic.
> - Logic for Blinky and Clyde are working, Pinky and Inky require some work.

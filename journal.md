# Developers Journal

This is an experiment to implement Pacman using the code generated by public LLMs.

## Step 1

***Prompt:***
Using a p5 library generate code for the classic Pacman game. Make sure the code can run.

> [!NOTE]
>
> - MS Copilot generates HTML file with JS code inline that only shows black canvas. Logic there is a no-go hallucination.
> - Gemini does generate a reasonable code. But it runs out of tokens and the code is unfinished. Need to find a workaround.

## Step 2

**Problem:** Code is not fully generated and is incorrect. Parts of the `Pacman` class aren't generated.

***Prompt:***
From the code above, only show the Pacman class

> [!NOTE]
>
> - Asked to generate class Pacman separately and now code is syntactically correct.
> - The code refers to Ghost class that is not defined anywhere.
> - Nothing is being drawn.

## Step 3

**Problem:** Nothing is being rendered. `setup` function is referring to `Ghost` class that is not defined.

***Prompt:***
`setup` function refers to `Ghost` that is not defined. Can you create a class for `Ghost`?

> [!NOTE]
>
> - Canvas was empty and the code is clearly missing the `Ghost` class, that we asked Gemini to generate.
> - Adding the newly generated `Ghost` class fixed the code and now we have at least maze and pacman visuals.
> - Ghosts aren't shown. Can't control pacman. No interactivity in general.

![Visuals after Step 3](/screenshots/step3.png)

## Step 4

**Problem:** Pacman doesn't respond to keyboard movements.

***Prompt:***
Pacman is not moving. How is it supposed to be controlled and what is the problem with that code?

***Answer (shortened):***

```markdown
Missing getAngle function: The show method in the Pacman class references a getAngle function that's not defined. This function is likely used to determine the direction Pacman is facing to draw the mouth correctly.

Incomplete canMove function: The canMove function only defines the logic to get the grid coordinates of the intended move but lacks the actual collision check with walls. It needs to check if the corresponding grid position in grid is "WALL" to prevent movement.

Missing update loop: The draw function doesn't have a loop to continuously update the game state. This means Pacman's position and direction won't change between frames, making it seem like it's not moving.
```

***Actions:***

- Adding `getAngle` function to `Pacman` class.
- Add wall checking logic to `canMove` method.
- Updated `draw` function doesn't have duplicated Ghost drawing rows.
- Newly added logic to `draw` related to `canMove` decisions is broken. Pacman is not rendered anymore.

## Step 5

**Problem:** Pacman stopped rendering as the result of the previous step.

***Prompt:***
Rendering of pacman broke, what is wrong with canMove related logic in the `draw` function?

***Answer (shortened):***

```markdown
The issue with the canMove related logic in the draw function is related to a variable typo. Here's the breakdown:

Typo in variable name: Inside the draw function, you're using gridy to access the grid array, but this variable isn't defined anywhere. It should be gridY which is correctly defined within the canMove function of the Pacman class.

Incorrect usage of `gridY`: The `canMove` function returns `grid[gridy] && grid[gridy][gridX] !== "WALL"`. This checks if `grid[gridy]` exists (which might be undefined due to the typo) and then checks its element at gridX. However, within the draw function, you're only using gridY for the first check, but not for accessing the element within the grid.
```

> [!NOTE]
> Gemini generates code with errors. We saw code given unfinished. Code referring to undefined classes and functions. Typos in variables, e.g. casing typos.

***Actions:***

- Fix `gridy` typos that must be `gridY` in `Pacman.canMove`.

Pacman is rendered again. Ghost appears too.
Pacman moves up on arrow key press, but not down or right.
Walls need fixing too, as Pacman position is inside the wall.

![Visuals after Step 5](/screenshots/step5.png)

## Step 6

**Problem:** Maze doesn't make sense and Pacman is positioned in the wall. Instead we want to have the classic level of 28x36 grid. Original tiles were 8x8 pixel, it's too small for modern screens, we can do 16x16 or 32x32.

***Prompt:***
Modify `createGrid` function to generate the classical pacman level with the grid of 28x36.

***Answer (shortened):***

```markdown
Here's the modified createGrid function to generate a classic Pacman level with a grid of 28x36:

<- code ->

This code defines an innerWalls array containing objects that specify coordinates for horizontal and vertical walls. The loop iterates through these objects and marks the corresponding cells in the grid with "WALL".
```

> [!NOTE]
>
> - This is a basic example.
> - Rendering broke again.

***Actions:***

- Replace `createGrid()` with the newly generated code.

## Step 7

**Problem:** Maze rendering broke.  It's not clear why Gemini insists on generating outer walls. Inner walls mix horizontal and vertical walls with different schemas.

***Prompt:***
There is a problem in `createGrid` can you identify and fix it?

***Answer (shortened):***

```markdown
The issue lies in the way the innerWalls array defines horizontal walls. Here's the breakdown:

Incorrect x-coordinate range for horizontal walls: The objects in the innerWalls array for horizontal walls define x1 and x2 to represent the starting and ending positions on the x-axis. However, these values should represent the column indexes in the grid, which range from 0 to width/cellSize - 1 (exclusive).
Currently, the code defines x2 as the ending position for drawing the wall. Since the loop iterates from x1 to x2 (inclusive), it will try to mark one extra cell beyond the intended end position  as "WALL" which might cause issues with rendering or collision detection.

Here's how to fix it:

<- code ->

By adjusting x2 in the horizontal wall definitions to be one less than the intended ending position, the loop will iterate up to the correct cell (inclusive), ensuring the wall is drawn within the grid boundaries.
```

***Actions:***

- This is not the problem breaking rendering, but the fact `createGrid()` redefines the global `grid` variable. Asking again

***Prompt:***
Why `createGrid` redefines `grid` that is already a global variable?

***Answer (shortened):***

```markdown
You're right, redefining grid inside the createGrid function might be unnecessary and can be confusing. Here's why it happens and how to improve it:

JavaScript variable scope: JavaScript has two main variable scopes: global and local. Variables declared outside any function (like grid here) are globally accessible. Variables declared within a function are local to that function.

Reassignment vs. redeclaration: In the createGrid function, you're not technically redeclaring grid. You're assigning a new empty array to the existing grid variable. This effectively wipes out any previous content in grid.

There are two ways to improve this:

Option 1: Utilize existing grid variable directly:

<- code ->

This approach removes the line grid = []; and directly uses the grid variable within the function. Since grid is already defined globally, it's accessible within the function.

Option 2: Use a local variable within createGrid:

<- code ->

This approach defines a local variable localGrid within the function to build the grid. After the loop finishes creating the grid structure, it assigns the entire localGrid to the global grid variable.

Both approaches achieve the same functionality but with slightly different strategies for handling the grid data. Choose the one that you find clearer or more suitable for your code organization.
```

***Actions:***

- Let's go with Option 2, but instead of assigning `grid = localGrid;` inside of it, lets ask `createGrid()` to return it.

***Prompt:***
Modify Option 2 to return `localGrid` instead of assigning it to `grid` variable. Modify the call to `createGrid` to use that returned value.

***Answer (shortened):***

```markdown
Here's the modified code utilizing Option 2 with createGrid returning the generated grid:

1. Modified createGrid function:

<- code ->

Instead of assigning the local grid to the global grid variable, the function now returns the localGrid using the return statement.

2. Modified call to createGrid:
   
<- code ->

In the setup function, the call to createGrid is used, and the returned value (the generated grid) is assigned to the global grid variable. This eliminates the need for direct assignment within the function.

This approach keeps the grid creation logic encapsulated within the createGrid function and separates it from modifying the global grid variable directly.
```

***Actions:***

- Rendering is still broken, because global `grid` is defined as a `const`. switch it to `let` similar to `pacman` and `ghosts`. Now it does render.

Only outer walls are rendered correctly. Canvas and grid size didn't change and is still a square.

![Visuals after Step 7](/screenshots/step7.png)

## Step 8

**Problem:** Grid is still 10x10, not 28x36. Canvas size is not increased either.

***Prompt:***
Change canvas size to accommodate the 28x36 grid with the cell size of 16 pixels.

***Answer (shortened):***

```markdown
To accommodate a 28x36 grid with a cell size of 16 pixels, you'll need to adjust the canvas size in the setup function. Here's the modified code:

<- code ->
```

> [!NOTE]
>
> - cell size is hardcoded: `const gridWidth = 28 * 16;`
> - It doesn't mention that `const cellSize = 40;` needs updating too, and thus all rendering is of size 40, not 16.

***Prompt:***
Cells are still of size 40 pixels, not 16.  Help to update.

***Answer (shortened):***

```markdown
You're right, the cells are still rendering at 40 pixels even though the canvas size is adjusted. The cell size is determined by how you draw elements within the grid. Here's how to fix it:

Update drawing functions: The size of the Pacman, ghosts, and potentially other elements in your code is likely defined based on the cell size. You need to update these drawing functions to use the actual cell size (16 pixels) instead of assuming it's the same as the canvas size.
Here are some examples:

Pacman:
<- code ->
```

> [!NOTE]
>
> - This is wrong. Gemini seem to forget about global `const cellSize = 40;` and instead suggests to hack Pacman and Ghost size `this.size = cellSize - 5; // Update size based on actual cellSize (16)`

***Prompt:***
Should I update the global cellSize instead?

***Answer:***

```markdown
No, it's generally better practice to avoid updating the global cellSize variable in this scenario. Here's why:

Maintainability: Using the actual cellSize (16) directly within the drawing functions makes the code clearer and easier to understand. It removes the need to mentally track the value of a global variable and its potential modifications throughout the code.

Flexibility: If you ever decide to change the cell size in the future, you only need to modify the value used within the drawing functions instead of updating a single global variable and potentially affecting other parts of the code unintentionally.

Encapsulation: Keeping the cell size definition within the context of the drawing functions promotes better encapsulation. Each function becomes more self-contained, relying on the provided cellSize value to draw elements correctly.

While there's nothing technically wrong with updating the global cellSize, the approaches mentioned above offer several advantages for code maintainability, flexibility, and clarity.
```

> [!NOTE]
>
> - This is plain wrong. Based on the original code generated. Gemini suggests to keep the original `40` that it came up with. Instead hack Pacman and Ghost. This doesn't solve the problem with wall sizes.
> - I'm going to fix it myself as it's pretty obvious change.

![Visuals after Step 8](/screenshots/step8.png)

## Step 9

**Problem:** Only the outer walls are generated, not the inner ones.

***Prompt:***
createGrid only generates the outer walls, but not the inner ones. Find and fix the problem there.

***Answer (shortened):***

```markdown
The problem lies in the conditional statement within the loop that creates the outer walls in the createGrid function. Here's the breakdown:

Outer wall condition: The current condition checks if x === 0 || x === width / cellSize - 1 || y === 0 || y === height / cellSize - 1 to mark cells as "WALL" for the outer boundaries.

Inner walls not considered: This condition only checks the edges of the grid (based on cell size and canvas size). It doesn't account for any additional walls you might want to define within the grid itself.

Here's how to fix it:

Option 1: Modify the loop condition (less flexible):

<- code ->

This approach changes the condition to true to mark all cells as "WALL" initially. Then, you'll need to add another loop or logic specifically designed to define the inner walls and set their corresponding positions in the grid to "EMPTY".

Option 2: Use a separate loop for inner walls (more flexible):

<- code ->

This approach keeps the outer wall creation logic. Then, it introduces a separate loop that iterates through the innerWalls array (defined as before) to set the corresponding cells in the grid to "WALL".

Option 2 is generally preferred as it allows for more flexibility in defining the inner walls without affecting the outer wall creation logic.
```

> [!NOTE]
>
> - Option 1 is meaningless, broken logic and doesn't take the inner walls in account at all.
> - Option 2 is exactly what the current broken logic does.

***Prompt:***
Why innerWalls array mixes names, for example some elements use {y, x1, x2} names while the other use {y1,y2, x}?  Does it work correctly with the nested for loops operating on innerWalls.forEach?

***Answer (shortened):***

```markdown
You're right, there's an inconsistency in the naming conventions used within the innerWalls array for defining walls. This inconsistency can lead to confusion and potential errors.
```

> [!NOTE]
>
> - While Gemini does claim inconsistency can be a problem, the newly generated code is exactly the same as it was before.

***Prompt:***
Should innerWalls be split into 2 arrays, for horizontal and vertical walls,  and the forEach loops be modified accordingly?

***Answer:***

```markdown
Splitting the innerWalls array into separate arrays for horizontal and vertical walls is a good approach and can improve code organization and readability. Here's how to implement it:

1. Separate arrays:
<-code->
2. Modified forEach loops:
<-code->

The loops now iterate through the respective arrays and use consistent naming for the loop variables (y for horizontal walls and x for vertical walls) based on the wall type being processed.

Advantages:

- Improved Readability: Separating walls by type makes the code easier to understand and maintain.
- Flexibility: Adding or removing walls of a specific type becomes simpler as you only need to modify the corresponding array.
- Maintainability: If the logic for processing horizontal and vertical walls differs, you can handle them within separate loops.
- This approach provides a well-organized way to define and manage the inner walls in your Pacman level.
```

> [!NOTE]
>
> - generated code uses `grid` not the `localGrid` we changed previously. This could be due to Gemini not knowing which option of the previous 2 we picked.
> - The walls look nothing like the classic pacman level.

## Step 10

***Prompt:***
Based on this picture of the classic Pacman game level, where walls are of blue color, generate the inner walls coordinates for `horizontalWalls` and `verticalWalls` arrays in our Pacman game.

***Answer:***

```markdown
Absolutely, based on a classic Pacman game level where walls are blue colored, here's a possible set of coordinates for the horizontalWalls and verticalWalls arrays:

Horizontal Walls (horizontalWalls array):

<-code->

Vertical Walls (verticalWalls array):

<-code (unfinished) ->
```

> [!NOTE]
>
> - Code was cut short. Had to ask to print the `verticalWalls` separately.
> - Resulted walls have nothing in common with the level we need.
> - Microsoft Copilot can't generate one either, replacing entries with comments, generating rows of different length and being in overall a waste of time.
> - Remove all the generating logic and replace it with a static array representing the level.
> - Replace "WALL" with 1
> - Hand draw the level

## Step 11

**Problem:** Pacman doesn't go right.

***Prompt:***

1. Pacman can move left, up and down, but doesn't move right. Fix it.
2. Is there a problem in `keyPressed()` function?

> [!NOTE]
>
> - Gemini is unable to find the typo in "RIGHT_arrow". Let's fix it ourselves.

## Step 12

**Problem:**

- Pacman doesn't align to the grid. It's shifted half a cell.
- Pacman's speed is too fast.

***Prompt:***
Pacman moves too fast, how to make it move slower and smooth?

***Answer:***

```markdown
There are a couple of approaches you can take to make Pacman move slower and smoother in your Pacman game:

1. Timer-based Movement:
<- code ->
2. Animation Loop:
<- code ->
```

***Prompt:***
Current logic in Pacman.move() makes Pacman move my a cell size. Make a better, more smooth per-pixel movement.

***Answer:***

```markdown
You're right, moving Pacman by a full cell size in each update can feel clunky. To achieve smoother per-pixel movement, we can leverage concepts like animation and frame rates. Here's an approach using requestAnimationFrame:

1. Update Pacman's Movement Speed:

Define a variable, for example, pacman.speed, to represent Pacman's movement speed in pixels per frame. A common starting point could be something like 2 pixels per frame.

2. Calculate Movement Distance:

Instead of directly moving Pacman by a full cell size, calculate the distance to move based on the speed and the time elapsed since the last update.
Here's an improved Pacman.move() function:

<- code ->
```

> [!NOTE]
>
> - `Pacman.move()` method is not being used.. It duplicates the logic in `draw()` function.

***Prompt:***
I don't see the move() function being used anywhere. Is it correct?

> [!NOTE]
>
> - Gemini started refactoring code to use `pacman.direction` `"RIGHT"` etc. instead of the previous logic of `setDirection(x, y)` operating on `pacman.directionX` and `pacman.directionY`

***Prompt:***
I don't see the move() function being used anywhere. Is it correct?

***Prompt:***
There is already a method `setDirection(x,y)` under Pacman class. Should the pacman's `directionX` and `directionY` attributes be used instead of newly introduced `direction` attribute?

***Answer (shortened):***

```markdown
You're absolutely right. It's better to leverage the existing setDirection(x, y) method and directionX and directionY attributes for Pacman's movement logic if they're already present in your codebase. Here's how to adapt the approach:
```

> [!NOTE]
>
> - `Pacman.move()` is still not used.

***Prompt:***
Show me how to integrate `Pacman.move()` into the animation loop using `requestAnimationFrame`. Dose grid and ghost drawing need updating?

> [!NOTE]
>
> - It explains how to use `requestAnimationFrame` with the new `animate()` function that will call `Pacman.move()`.
> - Not clear why do we need that `animate()` logic, if there is already the `draw()` function.

***Prompt:***
How does the new `animate()` function relate to the existing `draw()` function that is responsible for drawing? Do we need to use both?

> [!NOTE]
>
> - While what Gemini describes with splitting `animate()` and `draw()` makes sense, the `draw()` is the p5s lib callback.

***Prompt:***
Isn't our current `draw()` function part of p5js game library and that library calls it instead of us calling it directly?

***Answer (shortened):***

```markdown
You're absolutely correct. I apologize for the confusion in the previous explanation.

In the context of p5.js, the draw() function is indeed a core function provided by the library.  Here's a more accurate explanation:
```

> [!NOTE]
>
> - The movement and drawing logic gets more and more entangled.

***Prompt:***
Show me the overall `draw()` and the pacman's `move()` function.

> [!NOTE]
>
> - At this point Gemini starts going in loops and doesn't have a good history of our code. It started providing the general code that is a variation of what it suggested initially.
> - It's time to switch prompts to more precise and detailed ones. See if that can make some progress.

***Prompt:***
How does the `Pacman.move()` method is used with `Pacman.canMove(x,y)` method?

***Prompt:***
The current `move()` function operated with x and y being the pixels of the top left corner of the pacman. This function uses `canMove(x,y)` function that checks if pacman can move into a new location not occupied by the wall declared in the `grid` array.  But it `canMove(x,y)` only checks for the top left coordinates of pacman. Update `canMove` function to check all 4 corners.

> [!NOTE]
>
> - Lengthy reply is not that useful. It suggests doing 4 checks and OR-ing the checks, but that's what we already asked. The rest of code is useless restatements.
> - A few more tries to generate `canMove` that checks all 4 corners results in bad code offsetting `gridX` and `gridY` instead of `x` and `y`
> - Instead reuse the idea of top 4 corners, but have to implement it myself.

## Step 13

**Problem:** Pacman must not stop if keyboard command can't change that direction immediately, but instead apply it at the next possibility.

***Prompt:***
Already moving pacman stops if a new keyboard command points him into the wall. How does the `move()` `draw()` and `keyPressed()` functions need to change to ignore the change of direction if it's not possible at this moment?

> [!NOTE]
>
> - Gemini suggest to add "desired direction" that updates "direction" when pacman can move in the "desired" direction, but it's a faulty logic.

***Prompt:***
In the code above, while moving left the change in "desiredDirection" to go up will wrongly change the"pacmanDirection".

> [!NOTE]
>
> - Better, but with the repeating logic

***Prompt:***
Good, but there is a repeating logic that can be factored out into a function. Is it worth doing that?

***Prompt:***
Another problem is the code is missing the second check for `canMove` function. If else is executed no more collision check happens.

> [!NOTE]
>
> - Gemini keeps generating buggy code and have to be pointed out to fix it.

## Step 14

**Problem:** Ghosts aren't moving. Add the chasing logic. Also Pacman can't enter some of the tunnels.

***Prompt:***
Ghosts aren't moving, add logic to chase Pacman.

> [!NOTE]
>
> - Gemini provides the "simple chase logic" to define the direction. Code is reasonable, but needs heavy adaption from the `Pacman.move()`. At the end the chase, though a simple one, works.

## Step 15

**Problem:** Simple chase logic is too simple. Can Gemini help us to build a smarter one from the classic implementation of Pacman?

***Prompt:***
Can you provide a more complex chase logic that is used in real implementations of Pacman?

***Answer:***

```markdown
Absolutely! While the simple chase logic in the previous response provides a starting point, real Pacman implementations often utilize a combination of techniques for more interesting and challenging ghost behavior. Here's a breakdown of some common approaches:

1. Target Grid Approach:

Divide the maze into a grid of smaller cells.
For each ghost, define a target grid cell based on Pacman's current location or a predetermined pattern (e.g., scatter points).
The ghost uses a pathfinding algorithm (like A*) to find the shortest path to its target cell, avoiding walls.

2. Chasing Modes:

Implement different chasing modes for ghosts, like:
Chase Mode: Ghosts actively chase Pacman using the target grid approach.
Scatter Mode: Ghosts move away from specific scatter points in the maze (can be timed or triggered by Pacman's actions).
Frightened Mode: Ghosts become vulnerable and move randomly when Pacman eats a power pellet.

3. Field of View (FOV) Optimization:

Ghosts don't have complete knowledge of the entire maze.
Implement a limited field of view for each ghost, restricting their awareness of Pacman's location to nearby grid cells.
This can be achieved using techniques like raycasting or pre-calculated visibility maps.

4. Teaming and Cooperation:

In advanced versions, ghosts might collaborate.
For example, a chasing ghost might communicate Pacman's location to a strategically positioned ghost to cut him off.
Here's an example incorporating some of these ideas:

<-code->

Remember:

Replace the placeholder functions (getClosestPacmanCell, getScatterCell, findPath, getDirectionTowards) with your specific implementations based on your chosen pathfinding algorithm and FOV approach.
Adjust the chase threshold, ghost modes, and other parameters to fine-tune the ghost behavior for your game.
```

***Prompt:***
Generate `getDirectionTowards` function for the code above

> [!NOTE]
>
> - Generates the "simple chase" approach similar to what we used before.

***Prompt:***
Generate `findPath` function for the `ghostMove` function above.

***Answer (shortened):***

```markdown
The findPath function in the context of Pacman ghost AI typically involves a pathfinding algorithm to find the shortest path from the ghost's current position to a target cell within the maze. Here's an example using a basic Breadth-First Search (BFS) approach:
<- code ->
```

> [!NOTE]
>
> - Need a helper function that will look at the grid to filter out the wall cells.

***Prompt:***
Generate code for the `getValidNeighbors(x,y)` function that will look at the grid to avoid cells with walls.

> [!NOTE]
>
> - Great, we got something reasonably looking!
> - Path finding functions use grid coordinates, while pacman anf ghost use canvas ones. Need a function to convert between them

***Prompt:***
Create a function to convert from the canvas coordinates in pixels to cell coordinates in the grid.

> [!NOTE]
>
> - Since `Ghost.move()` method is a hack of several suggestions from Gemini, I had to patch it manually with proper conversions from the canvas coords into the grid coords using `canvasToGridCell()` Gemini just generated. Some hacking required to pass "cell" object instead Ghost or Pacman instances.
> - Ghosts are shown and move, but the movement is clearly broken.
> - At least nothing leads to code freezing.

## Step 16

**Problem:** Pacman is unable to enter some of the tunnels. This problem existed even before the addition of ghost logic. It's time to look at it, as it may affect the AI behind ghosts.

***Prompt:***
Pacman can't turn into some of the paths. Look at the Pacman movement code and see if something is wrong there.

***Answer (shortened):***

```markdown
Absolutely! Let's analyze the Pacman movement code to identify potential issues that might prevent him from turning into some paths:

Common Issues:

Collision Check Order:

Make sure the collision check happens after the desired direction change is applied to Pacman's position.
If the collision check is done before updating the position, it might prevent Pacman from entering a valid path even if the new position wouldn't lead to a collision.
Incomplete Collision Checking:

Ensure your canMove function considers all four corners of Pacman when checking for collisions with walls.
A simple check for the center of Pacman might miss collisions when entering narrow passages or making sharp turns.
Cell Snapping:

If you're using a cell-based approach for movement, there might be issues where Pacman's position gets snapped to the center of a cell after a movement update.
This can cause him to get stuck in corners or miss narrow paths if the snapping logic doesn't account for his desired direction.
Floating-Point Precision Errors:

Depending on how you calculate Pacman's movement based on speed and time, you might encounter floating-point precision errors.
These errors can lead to slight discrepancies between the intended movement and the actual position, potentially causing Pacman to miss some paths.
Code Review:

Here's a breakdown of some things to look for in your Pacman movement code:
```

> [!NOTE]
>
> - This is due to the `speed` variable set to 100. It causes Pacman to jam over the coordinates needed to enter the turn.

***Prompt:***
The problem happens due to the high speed value that causes pacman position to jump over the x,y coordinates corresponding to the wall opening cell. Suggest a code change to fix the problem.

***Answer:***

```markdown
Absolutely! You're right, a high speed value can cause Pacman to overshoot wall openings. Here's a code change to address this issue:

1. Movement Based on Cell Size:

Instead of directly calculating movement distances based on speed and time, we can tie the movement to the size of a cell in the grid. This ensures Pacman's movement aligns perfectly with the grid and avoids overshooting openings.

Here's an example code change:
<- code ->

2. Alternative: Snapping with Threshold

If directly calculating movement distances is preferred, you can implement a snapping mechanism with a threshold:
<- code ->
```

> [!NOTE]
>
> - Option 1 is a no go. It will make Pacman jump from cell to cell and will get in the way of animation, control etc. Won't work without some tricky animation based solutions on top.
> - Option 2 with snapping to the grid should work. Let's try it.

***Prompt:***
Factor out the snapping logic into a reusable function.

> [!NOTE]
>
> - Refactoring Gemini did is interesting: `function snapToCell(position, cellSize, threshold = 0.1 * cellSize) {` . `cellSize` is not used in the body of the function, only for the default value of `threshold`

***Prompt:***
Do we need to pass `cellSize` to `snapToCell` function?

***Answer (shortened):***

```markdown
You're right, there are ways to avoid passing cellSize to the snapToCell function every time. Here are two approaches:

1. Global Cell Size Variable:
2. Function Argument with Default Value:
```

> [!NOTE]
>
> - Gemini can't set it's mind on data structures. We have classes, array like objects representing x,y coords and the separate vars for x and y. Similar problem with canvas vs grid coords.
> - It's easier to change `snapToCell()` to operate on one coordinate than return both. Have to change it manually, as it is getting messy with Gemini.
> - there is a bug in `snapToCell` it only rounds within 1 pixel no matter how big is the threshold.

***Prompt:***
Look at `snapToCell` function, it only snaps within 1 pixel no matter how big is the threshold. Fix it.

***Prompt:***
This is still incorrect. the difference between a coordinate and it's rounded value is still within 1 pixel.

***Prompt:***
The problem is still there. We want to round 27 to 25, with the threshold of 0.5 and the cellSize 16

***Prompt:***
We have to snap within half of the cell, which is 8 pixels. For example x=6 is snapped to x=0. x=22 is snapped to 24. Checking `Math.abs(position.x - Math.round(position.x))` is incorrect, as this difference is always within 1 pixel.

> [!NOTE]
>
> - Here I give up because Gemini is clearly unable to understand and fix the problem.
> - Multiple other tests had shown Gemini really struggles with this kind of problems.

***Prompt:***
Suggest optimization to this function.  It detects collisions of 4 corners of pacman with walls and creates false positives. Function:
<- code of canMove ->

> [!NOTE]
>
> - While suggestion to reduce 4 corner checks is valid. Optimization is buggy. Gemini wrongly implies there is a direction info in these 4 coordinates, while there is none and thus conditional checks are wrong.

***Prompt:***
If I've implemented snapping to the grid, do I need to check all 4 corners of Pacman for collisions? If I do, modify this `canMove()` collision checker.
<- code of canMove ->

***Answer:***

```markdown
Yes, even with snapping to the grid, it's generally recommended to check all 4 corners of Pacman for collisions. Here's why:

1. Floating-point Precision Errors:
2. Sub-cell Collisions:

Modified canMove function:
<- code of canMove ->
```

> [!NOTE]
>
> - Gemini insists on the same buggy modification to `canMove()`.
> - The problem with snapping all coordinates is, when changing direction we aren't longer collide with the wall as the coordinates are snapped back into the current empty cell.

***Prompt:***
Without adding snapping to the grid into `move()` method of Pacman, Pacman can't turn into some of the corridors. With added snapping, the coordinates that otherwise be inside the wall on a direction change are snapped back into the open cell creating a false positive directional change. Provide suggestions on how to fix the problem.

***Answer:***

```markdown
Here are a few approaches to fix this problem:

1. Pre-Turn Check:
<- code ->
2. Post-Turn Snap with Tolerance:
<- code ->
3. Directional Snapping:
<- code ->
```

> [!NOTE]
>
> - (1) doesn't solve the problem as without snapping and with 4 point check, to turn we'd have to have a perfect alignment of pacman with the corridor next to it. 1 point check brings us back to previous bugs.
> - (2) doesn't work either, as it always snaps
> - (3) a no go either
> - It's getting hard to make Gemini design a working approach with incremental small movements of Pacman together with the snapping to grid. Let's try something different.

## Step 17

**Problem:** The maze is drawn over white background, that is visually distracting. Needs to be changed to black.

***Prompt:***
How to change the background of an empty html page from white to black

***Answer:***

```markdown
There are two main ways to change the background of an empty HTML page from white to black:
1. Using CSS:
This is the most common and recommended approach. Here's how to do it.

<- code ->
```

## Step 18

**Problem:** It's time to host our Pacman game somewhere. Let's try Github pages.

***Prompt:***
Give me step by step instructions on how can I host our pacman game on github pages

> [!NOTE]
>
> - Gemini instructions + minor lookup of Github docs and it's live: [https://bryndin.github.io/ai-coded-pacman/](https://bryndin.github.io/ai-coded-pacman/)

## Step 19

**Problem:** Collisions and snapping is still broken.

***Prompt:***
Pacman move logic has a collision problem. Suggest code modifications to resolve them.
In the `move()` function below `desiredDirX` and `desiredDirY` are the new desired direction for Pacman, while `directionX` and `directionY` are the current movement direction,  each can take values of -1, 0, or 1. `canMove` function checks 4 corners of Pacman against the grid to know if there is a wall or open space.
<- code ->

> [!NOTE]
>
> - Gemini suggests pre-turn checks and making `canMove` check all 4 corners, that we already told it we do.

***Prompt:***
My code already implements Option 1 and Option 2, and the collision issue is still there. Modify code to implement Option 3.

> [!NOTE]
>
> - Option 3 does a while loop moving Pacman "slower" not to overstep the tern. "slower" mins taking 0.1 of a step. This can still skip some pixels and lead to a missed turn.

***Prompt:***
The snapTolerance can still be over 1 pixel in length and thus can overstep the exact location of a corridor. Why not make snapTolerance to be exactly 1 pixel?

***Answer:***

```markdown
You're right, setting snapTolerance to exactly 1 pixel can seem like a good solution to avoid overstepping the corridor boundaries. However, there are potential drawbacks to consider:

Grid Imperfections: Even with a perfect grid representation in your code, there might be slight rounding errors during calculations (especially when dealing with floating-point numbers) that could cause Pacman to miss the exact corridor center by 1 pixel. This can still lead to collisions or jittery movement.

Floating-Point Precision: Computers often represent numbers using floating-point arithmetic, which can introduce slight inaccuracies. Setting snapTolerance to 1 pixel might not guarantee perfect snapping due to these limitations.

Snapping Issues: With a 1-pixel tolerance, Pacman might get stuck in narrow corridors where the combined width of Pacman and the corridor walls is less than or equal to the sum of his size and the tolerance (e.g., Pacman size = 10 pixels, corridor width = 11 pixels, tolerance = 1 pixel). He wouldn't be able to move in either direction because snapping to the center would always cause a collision.

Alternatives to 1-Pixel Tolerance:

Lower Tolerance with Buffer: You can keep the tolerance slightly lower than 1 pixel (e.g., 0.9) to avoid overstepping corridor boundaries in most cases. Additionally, you can introduce a small buffer zone around corridor walls (e.g., 0.1 pixels) within which collisions are ignored. This allows for slight inaccuracies and smoother movement.

Raycasting: Implement a raycasting system to check for clear paths in the desired direction before attempting movement. This can provide more precise collision detection and avoid the need for snapping altogether.

Combined Approach: Consider a combination of pre-turn checks, a slightly lower tolerance for snapping, and a small buffer zone for smoother movement. This approach might offer a balance between accuracy and visual appeal.

Considerations:

Carefully test your chosen approach to ensure Pacman moves smoothly within corridors without getting stuck or exhibiting jittery behavior.
Adjust values like tolerance and buffer size based on your specific grid size, Pacman size, and desired movement feel.
Remember: There's no one-size-fits-all solution, and the best approach might depend on your game's specific requirements and desired gameplay experience.
```

> [!NOTE]
>
> - Putting ray tracing aside, we can try to eliminate floating points by working with integers only.

***Prompt:***
At what rate does p5js lib calls the `draw()` function?

> [!NOTE]
>
> - Gemini tells us p5lib tries to draw at 60 fps. That can drop with complex animation or slow machines.

***Prompt:***
Do we need the currentTime and deltaTime multipliers, given that p5lib tries to draw at 60 fps?

***Prompt:***
If we remove that logic, we should be able to solve the collision problem if our grid cell size in pixels is divisible by the value of `this.speed` variable in the pacman coordinates calculation below. Is it correct?

***Answer (shortened):***

>Yes, you're absolutely correct! Removing the currentTime and deltaTime multipliers and ensuring the grid cell size is divisible by the speed value can potentially solve the collision problem in certain scenarios.

> [!NOTE]
>
> - Lets leave the speed factor be divisible of the cell size for now. To keep it simple.

## Step 20

***Prompt:***
Improve the following code and print the improved version

***Answer:***

><- code (partial) ->
>
>Improvements made include:
>
>Constants are defined in uppercase to indicate that they are constants.
>Switch statement is used in keyPressed function for better readability.
>Code comments are added for clarity in certain sections.
>Minor formatting adjustments for consistency and readability.
>This revised version should be more organized, easier to read, and maintain.

> [!NOTE]
>
> - None of the LLMs where able to look at the file at github. Pasting the entire JS code only (partially) worked in ChatGPT, that was able to suggest a few minor improvements and printed the first part of the file back. So the other parts are probably were cut due to the token size.
> - Current code is 6,249 tokens (See [Online Tokenizer](https://platform.openai.com/tokenizer)).
> - Context size. The exact context size for each of the Gemini, ChatGPT and MS Copilot is hard to find. Rumors vary significantly, ranging from 4k tokens to 32k. With the output being as small as 2k.
> - ChatGPT 3.5 (input+output: 16k, output: 4k). We don't know if this is the model deployed, nor if there is a 4k pre message limit.
> - Given that returned code if often cut or the functions are replaced with stabs, we could be hitting that 4k token limit.
> - Llama3-70b-8192 on Groq seem to have output limit around 2k tokens.
> - Conclusion, LLMs have problems working with the code of 6k tokens. We may want to refactor the code to be more decoupled, then work on independent parts separately.

## Step 21

**Problem:** The grid is not associated with the starting positions of Pacman and ghosts. Better have a concept of a level.

***Prompt:***
Generate a Javascript class representing a Pacman Level, that has a 2D layout defining the walls, starting position of Pacman, and starting positions of Ghosts per each unique ghost.

***Prompt:***
Add validation logic to PacmanLevel layout coming as an argument to constructor.

## Step 22

**Problem:** Design rendering logic. Do we want to separate rendering from content? Make it less reliant on global variables.

***Prompt:***
For the game Pacman, I have entities: GameBoard, Level, Pacman, Ghost. Explain different ways to organize the rendering of these entities in Javascript. I use p5play.js lib.

***Answer (Gemini):***

>Here are different ways to organize the rendering of entities in your Pacman game using p5play.js:
>
>**1. Individual Render Functions:**
>
>**2. Entity Class with render method:**
>
>**3. Component-based System:**
>* Define separate components for rendering (e.g., Renderer component) and logic (e.g., Movement component).
>* Each entity can have multiple components attached.
>* Have a separate system responsible for iterating through entities and calling the `render` method of their attached Renderer component.
>
>This approach offers more flexibility and separation of concerns but might be overkill for a simple Pacman game.
>
>**Choosing the right approach:**
>
>* For a simple Pacman game, approach 1 or 2 is probably sufficient.
>* If your game becomes more complex with many different types of entities and behaviors, approach 3 might be beneficial.

***Answer (Llama3):***

>**1. Single render function**
>
>**2. Entity-specific render functions**
>
>**3. Use a rendering layer system**
>
>**4. Use a scene graph**
>
>Choose the approach that best fits your game's requirements and complexity. You can always mix and match these approaches to create a hybrid solution that works best for your game.

> [!NOTE]
>
> - Rendering layers and scene graphs is an overkill for Pacman.
> - Complex rendering component is an overkill too.
> - As Gemini said, either do separate rendering functions or make them class methods.
> - For simplicity, lets keep entity classes separated from rendering logic and use standalone functions.

## Step 23

**Problem:** Let's see what important entities are we missing.

***Prompt:*** What are the main Javascript classes needed for Pacman game?

***Answer (llama3):***
>Here are the main JavaScript classes needed to implement a Pac-Man game:
>
>1. **Game**: The main game class, responsible for initializing and managing the game state, including the game loop, scoring, and level management.
>2. **PacMan**: Represents the Pac-Man character, handling its movement, collision detection, and interactions with the maze and ghosts.
>3. **Ghost**: A base class for the four ghosts (Blinky, Pinky, Inky, and Clyde), managing their AI, movement, and interactions with Pac-Man.
>4. **Maze**: Represents the game board, handling the layout, wall collisions, and pellet placement.
>5. **Pellet**: Represents individual pellets, including their placement, scoring, and consumption by Pac-Man.
>6. **PowerPellet**: A subclass of Pellet, representing the power pellets that allow Pac-Man to eat ghosts.
>7. **Fruit**: Represents the bonus fruits that appear in the maze, providing extra points when eaten by Pac-Man.
>8. **Score**: Manages the scoring system, tracking Pac-Man's points, lives, and level progress.
>9. **Level**: Represents a single level, handling the maze layout, pellet placement, and ghost behavior.
>
>Optional classes:
>
>1. **SoundManager**: Handles sound effects and music for the game.
>2. **InputManager**: Manages user input, such as keyboard or touch events, to control Pac-Man's movement.
>3. **Graphics**: Responsible for rendering the game graphics, including the maze, characters, and UI elements.
>
>These classes can be organized into a more detailed hierarchy, and some classes might be merged or split depending on the specific implementation. However, this list provides a solid foundation for building a Pac-Man game in JavaScript.

## Step 24

**Problem:** Everything but Pacman and Ghosts operate on "position" structure. Refactor them to match.

> [!NOTE]
> Refactoring with LLMs is not worth the time. Have to do it by hand.

## Step 25

**Problem:** We need a `Game` class to control the entire game.

***Prompt:*** Describe the `Game` class.

***Answer: (Gemini)***

>The `Game` class acts as the central control unit for your Pacman game. Here's a breakdown of its functionalities:
>
>**Initialization:**
>
>* Sets up the game world: Creates instances of `Maze`, `Pacman`, `Ghost` (potentially multiple), `Pellet`, and other necessary objects.
>* Initializes game variables like score, lives, and level.
>* Loads game assets like images and sounds.
>
>**Game Loop:**
>
>*  The core function that continuously updates the game state.
>* Manages the flow of the game by calling methods on other classes like:
>    *  `Pacman.move()` to update Pacman's position based on user input.
>    *  `Ghost.update()` to handle ghost movement and AI logic.
>    *  `Maze.checkCollisions()` to detect collisions between Pacman, ghosts, pellets, and walls.
>* Updates the game state based on these interactions:
>    *  Increase score for eaten pellets.
>    *  Decrease lives on collision with a ghost in chase mode.
>    *  Switch ghost behavior to frightened mode when a power pellet is eaten.
>    *  Check for win/lose conditions (all pellets eaten, no lives left).
>
>**Other functionalities:**
>
>* Handles rendering the game: Might directly call drawing functions on the game objects or interact with a separate graphics class.
>* Manages game states: Pausing, ending the game, and potentially handling transitions between levels.
>* May handle user input: Capturing key presses to control Pacman's movement.

***Prompt:*** Provide Javascript code for the Game class.

***Prompt:*** Remove all the rendering logic from `Game` class, it will be placed into a separate set of functions that you don't have to show. Show the updated class.

***Prompt:***

1. Describe why you need `canvas` attribute, remove it if not needed.
2. move game loop logic into the `draw()` function of p5play.js library.

***Prompt:*** `Game` class must receive an array of levels, and have logic to switch to next level.

> [!NOTE]
> `Game` class is not finished. We preserved Pacman movement, but the rest of logic is a stub.

## Step 26

**Problem:** Detect collisions between Ghost and Pacman.

***Prompt:** You're developing a Pacman game. You have 2 classes: `Pacman` and `Ghost`. `Pacman` class has the attribute `position`, an object with the x,y coordinates of the upper left corner, e.g. `{x: 1, y: 2}`; and `size`. `Ghost` has similar attributes `position` and `pacmanPosition` for the ghost and the Pacman positions respectively; and attribute `size`. Write Javascript code to detect collision between ghost and Pacman.

> [!NOTE]
> Gemini provides a slightly better optimized code, comparing to Llama3-70b.

***Prompt:** In the Pacman game, you have 3 entities: Pacman, Ghost, and GameBoard, represented by Javascript classes. Which one is responsible for checking for a collision between Pacman and Ghost, and why?

> [!NOTE]
> Both LLMs suggest the `GameBoard` class to handle collision checks. Why?
>
> - Gemini: Centralized Knowledge, Separation of Concerns, Efficiency, Game State Management.
> - Llama3-70b: Single Responsibility Principle, Game Logic, Decoupling, Centralized Game State.

***Prompt:** Update the collision logic to have the collision function in the `Game` class, instead of the `Ghost` class. Generate Javascript code.

> [!NOTE]
> Gemini generates a slightly better code, factoring out the collision logic into a separate variable. When Llama3 injected the large `if` check inline.

## Step 27

**Problem:** When Ghost touches Pacman nothing happens. Implement the life loss functionality.

***Prompt:*** You are a game developer implementing a Pacman game. What happens when Ghost touches Pacman? Explain everything that is happening with the game state, animation, etc.

***Answer (MS Copilot):***
>When a Ghost touches Pacman in the game, several things happen:
>
>1. **Game State Update**: The game state changes to reflect that Pacman has been caught by a ghost. This could involve setting a variable like `pacmanCaught` to `true`.
>
>2. **Lives Update**: Pacman's lives count decreases by one. If Pacman has no lives left, the game state changes to `GameOver`.
>
>3. **Animation**: An animation plays to show Pacman being caught by the ghost. This could be Pacman flashing, changing color, or some other visual effect.
>
>4. **Sound Effects**: A sound effect plays to indicate that Pacman has been caught. This helps to alert the player to what has happened.
>
>5. **Score Update**: The player's score may be updated. Depending on the game rules, the score could decrease as a penalty for being caught, or it could stay the same.
>
>6. **Reset Positions**: After the catch animation and sound have played out, Pacman and the ghosts are usually reset to their starting positions, and play resumes.
>
>7. **Game Speed**: In some versions of the game, the speed of the ghosts relative to Pacman might increase each time Pacman is caught, making the game progressively harder.

> [!NOTE]
> While both Gemini and LLama3 have similar answers, the Llama3 `Score Reset: The score is reset to zero, and the game starts fresh.` part is incorrect. Microsoft Copilot and ChatGPT3.5 answers are also similar. They are more concise and listed by execution order, instead of grouping into State/Animation/Sound as the first two.

## Step 28

**Problem:** Game logic becomes complex, it's more transparent to operate based on a state machine.

***Prompt:*** You are game developer creating a classic Pacman game in Javascript. You have classes GameBoard, Pacman, Ghost.  Class GameBoard controls the game and operates on game states. List all the states for the GameBoard that are needed for the game to work.

***Answer (MS Copilot):***
>Sure, here are some of the potential states that the `GameBoard` class might need to manage in a classic Pacman game:
>
>1. **`Start`**: This is the initial state of the game. The game waits for the player to start the game.
>
>2. **`Running`**: This state indicates that the game is currently in progress. Pacman and the ghosts are moving around the board.
>
>3. **`Paused`**: In this state, the game is temporarily halted, usually due to player action. Pacman and the ghosts are not moving.
>
>4. **`PacmanCaught`**: This state is triggered when a ghost catches Pacman. It might initiate an animation or sound effect and lead to a decrease in Pacman's lives.
>
>5. **`LevelComplete`**: This state is triggered when all the dots on the board have been eaten by Pacman. The game might display a message or animation, then proceed to the next level.
>
>6. **`GameOver`**: This state is triggered when Pacman has no lives left. The game might display a "Game Over" message and wait for the player to start a new game.
>
>7. **`PowerUp`**: This state is triggered when Pacman eats a power pellet. The ghosts change their behavior (usually they run away from Pacman), and the game might display a different animation or sound effect.
>
>Remember, these are general states and can vary based on the specific implementation of the game. The key is to manage these states appropriately to ensure the game runs smoothly. Each state might also have associated actions that are triggered when entering or exiting the state. For example, when entering the `GameOver` state, the game might play a specific sound effect, display a message to the player, and update the high score list. When exiting the `GameOver` state (i.e., starting a new game), the game would reset all game variables to their initial values.

> [!NOTE]
> MS Copilot gave the best option and described it in the simplest terms. Gemini came close. Llama3 had extra steps, e.g. `WAITING_FOR_INPUT`, `ANIMATING` that aren't a good fit.

***Prompt:*** Create a finite state machine for the states you've provided.

> [!NOTE]
> MS Copilot has concise explanation. It even tried to draw the states in pseudo graphics, but hallucinated in state transitions. Gemini didn't draw, bet described it well, though the answer were harder to process.

***Answer (MS Copilot):***
>Sure, here's a simple representation of a finite state machine for the Pacman game:
>
>```plaintext
>+-----------+     +---------+     +--------+     +-------------+
>|           |     |         |     |        |     |             |
>|   Start   +-----> Running +-----> Paused +-----> PacmanCaught |
>|           |     |         |     |        |     |             |
>+-----+-----+     +----+----+     +---+----+     +------+------+
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      |                |              |                 |
>      v                v              v                 v
>+-----+-----+     +----+----+     +---+----+     +------+------+
>|           |     |         |     |        |     |             |
>| GameOver  <-----+ Level   +<----+ PowerUp+<----+ PacmanCaught |
>|           |     | Complete|     |        |     |             |
>+-----------+     +---------+     +--------+     +-------------+
>```
>
>- **Start**: The initial state of the game. The game waits for the player to start the game.
>- **Running**: The game is currently in progress. Pacman and the ghosts are moving around the board.
>- **Paused**: The game is temporarily halted, usually due to player action. Pacman and the ghosts are not moving.
>- **PacmanCaught**: Triggered when a ghost catches Pacman. It might initiate an animation or sound effect and lead to a decrease in Pacman's lives.
>- **PowerUp**: Triggered when Pacman eats a power pellet. The ghosts change their behavior (usually they run away from Pacman), and the game might display a different animation or sound effect.
>- **LevelComplete**: Triggered when all the dots on the board have been eaten by Pacman. The game might display a message or animation, then proceed to the next level.
>- **GameOver**: Triggered when Pacman has no lives left. The game might display a "Game Over" message and wait for the player to start a new game.
>
>Each arrow represents a transition from one state to another. The direction of the arrow indicates the direction of the transition. For example, the game can go from the `Start` state to the `Running` state, but not the other way around. The game can transition from almost any state to the `GameOver` state, reflecting the fact that the game can end at any time if Pacman runs out of lives. Note that this is a simplified model and actual implementation might have more states and transitions.

***Answer (Gemini):***
>Here's a finite state machine representation for the Pacman game states:
>
>**States:**
>
>* Setup
>* Running
>* Pacman Dead
>* Level Complete
>* Paused
>* Game Over
>
>**Transitions:**
>
>* Setup -> Running: This happens when the initial game board is created and ready for gameplay.
>* Running -> Pacman Dead: This occurs when Pacman collides with a ghost.
>* Running -> Level Complete: This triggers when Pacman eats all the dots on the current level.
>* Running -> Paused: This happens when the user pauses the game.
>* Paused -> Running: This occurs when the user resumes the game from a paused state.
>* Running -> Power Pellet Active (Sub-state): This is a temporary transition within Running when Pacman eats a power pellet.
>* Power Pellet Active -> Running: This transition happens when the power pellet effect wears off.
>* Running -> Ghost Frightened (Sub-state): This is another temporary transition within Running when Pacman eats a power pellet, making ghosts vulnerable.
>* Ghost Frightened -> Running: This occurs when the ghost vulnerability period ends.
>* Level Complete -> Running (Optional): This could be used to restart the current level.
>* Level Complete -> Next Level (Optional): This would transition to a new level if available.
>* Pacman Dead -> Game Over (Optional): This happens if the player has no more lives left.
>* Pacman Dead -> Running (Optional): This could be used to restart the current level with a life cost.
>
>**Events:**
>
>* Game Start: Triggers the transition from Setup to Running.
>* User Input (Movement, Pause): Triggers transitions based on player actions.
>* Collision (Pacman-Ghost): Triggers the transition from Running to Pacman Dead.
>* Dot Eaten (Last Dot): Triggers the transition from Running to Level Complete.
>* Power Pellet Eaten: Triggers the temporary transition to Power Pellet Active within Running.
>* Power Pellet Effect Ends: Triggers the transition back to Running from Power Pellet Active.
>* Ghost Eaten (By Pacman): Triggers the temporary transition to Ghost Frightened within Running.
>* Ghost Vulnerability Ends: Triggers the transition back to Running from Ghost Frightened.
>* Level Completion Logic: Determines if the game progresses to the next level or restarts the current one.
>* Game Over Condition (Lives Depleted): Triggers the transition from Pacman Dead (or any state) to Game Over.
>
>**Notes:**
>
>* This is a simplified FSM, and additional states or transitions might be needed depending on the complexity of your game.
>* The optional transitions allow for design choices on how the game handles restarts, level progression, and handling Pacman deaths.
>* Sub-states like Power Pellet Active and Ghost Frightened can be implemented within the Running state for temporary behavior changes.

***Prompt:*** Create a finite state machine for the states you've provided.

> [!NOTE]
> MS Copilot has concise explanation. It even tried to draw the states in pseudo graphics, but hallucinated in state transitions. Gemini didn't draw, bet described it well, though the answer were harder to process.

***Prompt:*** Generate Javascript code for the GameBoard class that contains all these states. Add logic to check the state and execute game logic based on that state.

> [!NOTE]
> We use a mix of code from MS Copilot and Gemini. Gemini generated a dedicated static object listing all state constants, while Copilot didn't. But Copilot generates chunks of game logic for each state that we will reuse. Unrelated, Copilot uses too much space between code lines visually, that makes it harder to read compared to Gemini.

## Step 29

**Problem:** Number of lives and score aren't displayed.

***Prompt:*** You're developing the game Pacman in Javascript. Generate code that uses p5play.js lib to display the current score and Pacman lives on the canvas.

## Step 30

**Problem:** Game have no pellets and thus no winning.

***Prompt:*** You are game developer creating a classic Pacman game in Javascript. You have classes GameBoard, Pacman, Ghost. Explain how pellets have to be implemented there.

***Answer (Gemini):***
>There are a few ways to implement pellets in your classic Pacman game using Javascript and the classes you mentioned:
>
>**1. Multi-dimensional Array in GameBoard:**
>
>**2. Separate Pellet Class:**
>
>**3. Combining both approaches:**
>
>* Use a 2D array for the overall layout in `GameBoard`.
>* Within the array elements representing empty spaces, store references to `Pellet` objects (if any).
>* This allows flexibility in defining different types of pellets and simplifies adding/removing them during gameplay.
>
>**Pacman and Pellet Interaction:**
>
>* In the `Pacman` class, implement a collision detection method that checks if Pacman's position overlaps with a pellet's position (using either array index or object reference).
>* Upon collision:
>    * Remove the pellet from the board (array or object list).
>    * Update the game score in `GameBoard`.
>    * Play a sound effect (optional).
>
>**Remember:**
>
>* Whichever method you choose, ensure efficient collision detection to optimize game performance.
>* Consider adding a property to the `Pellet` class to track if it's been eaten, allowing removal from the board only once.
>
>These are some ways to implement pellets in your Pacman game. Choose the approach that best suits your project structure and coding style.

***Prompt:***
You're developing the game Pacman in Javascript. You have a class `Level` provided below. `layout` argument is a 2D array describing the level, pellets are represented by "." character there. Modify class `Level` to parse the layout, count and store the number of pellets. Provide a function or a method to remove pellet from the provided coordinates.

class Level {
  constructor(layout) {
    this.layout = layout;
    this.height = this.layout.length;
    this.width = this.layout[0].length;
  }
}

***Prompt:*** Modify `removePellet` to throw an exception if x and y are outside of the layout size.

***Prompt:*** Using Javascript lib p5play.js generate code to draw a pellet from the Pacman game.

***Prompt:*** In the `draw()` function, replace the `if` check with the switch/case logic.

> [!NOTE]
> Gemini did a good job providing code. For the level layout to save time we updated it manually.

***Prompt:*** You're developing the game Pacman in Javascript. You have a class `Game` representing main game logic. Function `main()` is the main game loop. The state `Game.states.RUNNING` means Pacman is moving. `level` is an instance of class `Level`. `layout` is a 2D array representing the level, where "." character is a pellet.
To the code below add functionality of Pacman eating pellets and thus increasing the score in `score` attribute.

class Level {
  constructor(layout, pacmanStart, ghostStarts) {
    this.layout = layout;
    this.pellets = this.countPellets();
  }
}

class Game {
  constructor(level) {
    this.level = level;
    this.score = 0;
    this.state = Game.states.RUNNING;
    this.pacman = new Pacman(level.pacmanStart, CELL_SIZE, 2);
  }

  main() {
    switch (this.state) {
      case Game.states.RUNNING:
        this.pacman.move();

        if (this.checkPacmanGhostCollision()) {
          this.setState(Game.states.PACMAN_DEAD);
        }

        if (this.isLevelComplete()) {
          this.setLevel(this.currentLevelIndex + 1);
        }

        if (this.checkGameCompletion()) {
          this.setState(Game.states.GAME_OVER);
        }

        break;
    }
  }
}

***Prompt:*** Why does `checkPelletCollision` modify the state of the Game, being a "check" method?

***Prompt:*** Use Option 2, where logic is in the `main()` function. There is a problem with `this.level.layout[this.pacman.y][this.pacman.x]` code. `layout` uses layout local coordinates, while `pacman` uses canvas coordinates. Fix it.

***Answer: (shortened)***

>```javascript
>  const cellX = Math.floor(this.pacman.x / CELL_SIZE);
>  const cellY = Math.floor(this.pacman.y / CELL_SIZE);
>  if (this.level.layout[cellY][cellX] === ".") {
>    this.level.layout[cellY][cellX] = " ";
>    this.score += 10;
>```

***Prompt:*** There still could be a problem related to `Math.floor`. Most of the Pacman can be already located in the next cell, but the top left corner of Pacman (`this.pacman.x` and `this.pacman.y`) can be still in the previous cell.

***Answer: (shortened)***
>You're absolutely right. Using `Math.floor` alone might lead to situations where Pacman is mostly in the next cell but its top left corner is still considered in the previous cell, causing missed pellet detections. Here are two approaches to address this:
>
>**Approach 1: Check for overlapping with both current and next cell**
>
>**Approach 2: Use a threshold for cell occupancy**
>
>**Choosing the Approach:**
>
>* Approach 1 might be more complex but offers more precise detection, especially for faster Pacman speeds.
>* Approach 2 is simpler but relies on a chosen threshold value, which might require some experimentation for optimal results.

***Prompt:*** 
Going with Approach 1, would it be better to check 4 cells instead of 2? The current one plus the one to the left, the one below and the one below to the left?

***Answer(shortened):***
>While checking four cells (current, next in movement direction, and diagonally below/left) might seem more comprehensive for pellet detection, it can introduce unnecessary complexity and potential issues. Here's why:

***Prompt:***
Approach 1 can make Pacman prematurely eat a pellet in the next cell.  Why not use the collision check instead? We can compute the sprite size for the pellet in the canvas coordinates.

***Answer(shortened):***
>You're right, Approach 1 with just checking the next cell based on movement direction can lead to premature pellet eating. Here's how we can leverage the collision detection logic to achieve more accurate pellet consumption using the pellet sprite size:
>
>**1. Define Pellet Information:**
>
>* Introduce a new property in the `Level` class to store the pellet sprite size:
>
>**2. Modify `main()` Function:**
>
>* Instead of checking the next cell based on direction, use the collision detection logic to check for overlap with the current cell's pellet:
>
>**Explanation:**
>
>1. We calculate the exact coordinates of the pellet's bounding box in canvas space based on its position in the level layout (`cellX`, `cellY`) and the defined `pelletSize`.
>2. We call the `isColliding` function (assuming you have one for collision detection) to check if Pacman's sprite overlaps with the calculated pellet bounding box. 
>3. If there's a collision and the tile is a ".", we remove the pellet from the layout and update the score.
>
>This approach leverages the existing collision detection logic for more accurate pellet eating detection based on the actual sprite sizes of Pacman and the pellet.
>
>**Note:**
>
>* Ensure your `isColliding` function can handle both rectangle-to-rectangle and circle-to-rectangle collisions, depending on how you represent Pacman and the pellet sprites.

***Prompt:***
This again has the problem when most of the Pacman sprite is in the next cell, touching the next pellet sprite that this logic won't detect.

***Answer (shortened):***
>You're absolutely right. The previous approach based solely on the pellet's bounding box might still miss pellets when Pacman is mostly in the next cell. Here's a refined solution that combines collision detection and a threshold for Pacman's position within a cell:
>
>**1. Define Threshold and Pellet Information:**
>
>* Introduce a `cellOccupancyThreshold` property in the `Game` class:
>
>**2. Modify `main()` Function:**
>
>* Combine collision detection with the threshold check:
>
>**Explanation:**
>
>1. We calculate the `isPastThreshold` flag to check if Pacman's X position is beyond the threshold point within the current cell.
>2. The pellet is considered eaten if:
>    * The tile is a "." (pellet) and
>    * EITHER Pacman is past the threshold within the current cell (ensuring it's not just touching the edge) OR
>    * There's a collision between Pacman and the pellet's bounding box.
>
>This approach combines the strengths of both previous solutions:
>
>* It leverages collision detection for more precise handling of sprite overlaps.
>* It uses the `cellOccupancyThreshold` to ensure Pacman doesn't eat a pellet in the next cell too early.
>
>**Adjusting the Threshold:**
>
>The `cellOccupancyThreshold` value impacts how deep Pacman needs to be within a cell to be considered occupying it for pellet consumption. Adjust this value based on your desired behavior and pellet size. 
>
>* A higher threshold ensures Pacman is further into the current cell before eating a pellet, potentially reducing the feeling of "premature" eating.
>* A lower threshold allows Pacman to eat pellets slightly earlier as it enters a cell.
>
>**Testing and Refinement:**
>
>Test your game with different threshold values to find the sweet spot that balances responsiveness and pellet eating accuracy for your specific game design. Remember, the ideal value might depend on factors like Pacman's speed and pellet size.

***Prompt:***
This introduces a magic number for a threshold that could lead to some hidden bugs. Why not check the 4 neighboring pellets and do a collision check with all 4?

***Answer (shortened):***
>You're right, using a magic number for the threshold might not be ideal and could lead to unexpected behavior in certain scenarios. Here's why checking all four neighboring pellets with collision detection can be a viable solution, with some considerations:
>
>**Benefits:**
>
>* **Reduced reliance on magic numbers:** By checking all four neighbors, we eliminate the need for a specific threshold value, potentially improving code maintainability and reducing the likelihood of hidden bugs related to the threshold.
>* **More comprehensive detection:** Checking all four neighbors ensures Pacman can eat pellets even if it's positioned diagonally between cells, offering a more complete solution.
>
>**Drawbacks:**
>
>* **Increased complexity:**  Checking four pellets with collision detection requires more calculations compared to checking the current cell and potentially the next one in movement direction. This might not be a significant performance hit for a simple Pacman game, but it's a factor to consider, especially for larger or more complex games.
>* **Potential for over-detection:** Depending on the implementation of the collision detection and pellet/Pacman size, there's a slight chance of Pacman eating pellets it shouldn't reach if it's perfectly positioned between cells.
>
>**Implementation:**
>
>Here's how you can implement checking all four neighboring pellets: ...
>
>**Explanation:**
>
>1. We define additional checks for the left, right, and top neighboring pellets based on their calculated bounding boxes.
>2. The `isPelletEaten` flag is set to `true` if any of the collision checks with the neighboring pellets return `true`.
>3. We only update the layout and score if there's a collision and the corresponding tile in the layout is a "." (pellet).
>
>**Choosing the Approach:**
>
>The decision between checking four neighbors with collision detection and a threshold-based approach depends on your game's priorities. 
>
>* If you prioritize simplicity and reducing magic numbers, checking four neighbors might be a good choice. Just be aware of the potential for slight over-detection in some scenarios.
>* If performance is a concern and you want a more precise control over Pacman's pellet eating behavior, a refined threshold-based approach with well-tested threshold values might be preferable.
>
>Ultimately, test both approaches in your game and see what works best for your specific design goals and desired level of pellet consumption accuracy.

***Prompt:***
This code will make Pacman eat at most one pellet, while Pacman sprite might touch several. Modify the code that if Pacman collides with several pellet sprites, each of them is removed from the level layout and increase the score.

***Prompt:***
You get cell coordinates from the Pacman canvas coordinates, `cellX` and `cellY`. Check that cell and the cells to the right, down, and right down, if any of them have a pellet, compute the sprite box for that pellet and use it to check for collision with Pacman.

> [!NOTE]
> This is where Gemini starts generating crazy code. Lets start over.


You're developing the game Pacman in Javascript. You have class `Level` with an attribute `layout` being a 2D array representing the level. "." character in the array cell is a pellet.
Class `Pacman` has attribute `position` that holds x,y coordinates of the top left sprite corner in canvas space.
Class `Game` contains a method `main()` responsible for the game logic.

After `this.pacman.move();` code add logic that checks for Pacman collision with pellets in four neighboring cells: current, one to the right, one below, one below to the right. If there is a pellet in a cell, compute its collision box in convas coordinates and check against collision with Pacman using `checkForOverlap` function. If there is a collision, increase the game score and remove the pellet from the layout via `removePellet` function.

```javascript
class Level {
  constructor(layout, pacmanStart, ghostStarts) {
    this.layout = layout;
    this.pellets = this.countPellets();
  }

  removePellet(x, y) {
    // this function removes pellet from the layout
  }
}

class Pacman {
  constructor(size) {
    this.position = {x: 1, y:10};
    this.size = size;
  }
}

class Game {
  constructor(level) {
    this.level = level;
    this.score = 0;
    this.pacman = new Pacman(level.pacmanStart, CELL_SIZE, 2);
  }

  main() {
    this.pacman.move();

    // here add the needed logic
  }
}

function checkForOverlap(obj1Position, obj2Position, obj1Size, obj2Size) {
  return (
    (obj1Position.x < obj2Position.x + obj2Size && obj1Position.x + obj1Size > obj2Position.x) &&
    (obj1Position.y < obj2Position.y + obj2Size && obj1Position.y + obj1Size > obj2Position.y)
  );
}
```

> [!NOTE]
> Both Gemini and Copilot did an ok-ish job with the code this time, though using different approaches for iteration. BUT both use canvas coordinates in cell calculations, when they can simply add +1 to the level coordinated.

***Prompt:***
You use canvas coordinates to calculate cell coordinates on each iteration. Why not to calculate it once, then next cell in the layout coordinates will be just +1.

***Prompt:***
Do you need to check your cell x and y are within the layout limits?

> [!NOTE]
> Copilot added the check, yet it didn't figure out `x >= 0` one is redundant. Gemini claimed their code is alright, providing 2 points why. While one is based on JS voodoo and can hold, the other about throwing an exception is incorrect. We want to check, not to raise an exception to player.

***Prompt:***
Write a function in Javascript to convert an array of the form `["#..", "#.#"]` into array `["#", ".", "."], ["#", ".", "#"]`

## Step 31

**Problem:** Code uses hardcoded level elements, e.g. "#", ".". Use constants instead.

> [!NOTE]
> This is a simple refactoring, that is not worse dealing with complex LLM prompts.

## Step 32

**Problem:** Level layout and related information takes screen space and complicates working with code. Also it won't scale well adding more levels. Move it into a dedicated file.

***Prompt:***
In a Javascript project implementing the game Pacman, how to define levels in separate files, to be read from the main logic? Provide code example.

> [!NOTE]
> After dozens of tries with both Gemini and Copilot we encountered all possible hallucinations related to async processing, e.g.
>
> - (Copilot): `Promise.all(promises) maintains the order of the results based on the order of the promises, not the order of resolution.`
> - (Gemini): `No, Promise.all(promises)  does not maintain the order of the results based on the order the promises were added to the array. It resolves with an array containing the results of the fulfilled promises in the order they resolved, not the order they were created in.`
>
> Gemini constantly hallucinates about `async`, e.g.
>
> - skipping `async` declaration while using `await`.
> - seeing `async` where there is non declared.
>
> We really struggled with both LLMs and had a hard time to get a bug free code.

***Prompt:***
Generate javascript code that extracts the file name from a file path, e.g.
path: `levels/1.json` answer: `1`

***Prompt:***
in javascript how to convert "1" (char) into 1 (int)?

***Answer:***
>p5play.js itself doesn't provide a direct way to stop the game entirely upon an exception. However, you can achieve a similar effect using a combination of error handling and potentially modifying your code structure. Here are two approaches:
>
>**1. Throwing an Error from Within Your Code:**
>
>**2. Conditional Execution based on Successful Preloading:**
>
>**Choosing the Approach:**
>
>* Throwing an error is a simpler approach for critical errors that prevent the game from functioning correctly.
>* Conditional execution offers more flexibility for handling specific preload failures and providing alternative behavior (e.g., displaying an error message).
>
>Consider the nature of potential errors in your game and choose the approach that best suits your needs.
>
>**Additional Tips:**
>
>* You can use a similar approach to handle errors during the game loop (`draw` function) itself. If a critical error occurs during gameplay, throw an error or set `gameRunning` to `false` to stop the game.
>* Consider using a global error handler using `window.onerror` to catch any unhandled errors that might occur during the game. This can provide a more robust error handling mechanism.

***Prompt:***
You are developing a Pacman game in Javascript. You code layout consists of files
level.js declares class Level with an attribute layout.
pacman.js contains an array of all instances of levels.
levels is a directory holding javascript files containing data for each level, e.g. the level layout.
levels/1.js, levels/2.js files etc. instantiate class Level defined in level.js and make it available for the pacman.js file.
Generate code representing the above using ES6 syntax.

> [!NOTE]
>
> - We don't want to convert Pacman into an async app. Async fetching JSON blobs isn't an option.
> - Doing sync http requests don't look exciting either.
> - Let's use code imports instead.

***Prompt:***
You are developing a Pacman game in Javascript. You code layout consists of files
  - `level.js` declares class `Level` with an attribute `layout`.
  - `pacman.js` contains an array of all instances of levels.
  - `levels` is a directory holding javascript files containing data for each level, e.g. the level layout.
  - `levels/1.js`, `levels/2.js` files etc. instantiate class Level defined in `level.js` and make it available for the `pacman.js` file.
Generate code representing the above using ES6 syntax.

***Prompt:***
Explain export default { layout }; part, why not `export default layout;

***Prompt:***
Why am I getting "Cannot use import statement outside a module" error about pacman.js?

***Answer (shortened):***
>The error "Cannot use import statement outside a module" arises because you're trying to use `import` statements in a script that isn't treated as a module by your browser or environment.  Here's why and how to fix it:
>
>**Solutions:**
>
>1. **Use a Module Loader (e.g., Webpack, Parcel)**
>
>2. **Set the `type` Attribute in `<script>` Tags**
>
>* **For Larger Projects:**  Module loaders (Webpack, Parcel) are highly recommended for larger projects because they offer more control and features for managing dependencies.
>* **For Smaller Projects or Prototypes:** The `type="module"` attribute is a simpler way to get started.

***Prompt:***
Content of file `1.js`:
```
const levelName = "Level 1";
const difficulty = "Easy";
export default { levelName, difficulty };
```

Content of file `2.js`:
```
const levelName = "Level 2";
const difficulty = "Hard";
export default { levelName, difficulty };
```

Give me an example on how to import all these variables in file `pacman.js`. If name clashes is a problem, suggest a solution.

***Answer (shortened):***
>You're right, name clashes are a problem when importing from multiple files with the same variable names. Here's how to handle this and a couple of solutions:
>
>**Direct Import with Renaming**
>
>
>**Importing into Objects (Namespaces)**

***Prompt:***
`pacman.js` contains functions `setup()` and `draw()` that are called by p5play.js lib.
After adding `type="module"` in front of `src="pacman.js"` in `index.html` these functions are no longer being called by the p5play lib. Why and how to fix it?

***Answer (Gemini):***
>The issue arises because adding `type="module"` in front of `src="pacman.js"` in `index.html` changes how the script is loaded. Here's the breakdown:
>
>Here are two ways to fix this:
>
>1. **Export Functions from pacman.js:**
>
>2. **Use the `window` Object:**

***Answer (Copilot):***
>
>```javascript
>// Add setup and draw to the global scope
>window.setup = setup;
>window.draw = draw;
>```

> [!NOTE]
>
> - Neither of 2 solutions from Gemini worked.
> - Copilots solution did work.

## Step 33

**Problem:** Move Renderer class into a separate file.

## Step 34

**Problem:** Factor out the rest of classes into separate files.

## Step 35

**Problem:** Ghosts must be able to move not only to empty space, but any space that is not a wall.

***Prompt:***
Does Javascript have a concept of set, a data structure to quickly lookup at?

## Step 36

**Problem:** Ghosts navigation is broken.

***Prompt:***
You are developing a Pacman game in Javascript. You have class `Ghost` listed below and variable `layout` that is a 2D array of the level, where the wall is defined by the constant `WALL`. Ghost has a method `move(layout, targetPosition)` with arguments of current level layout and the position of Pacman to go to, `targetPosition` is an object with x,y coordinates, e.g. `{x: 1, y: 4}`.
Ghost moves in canvas coordinates. Size of one level layout cell is stored in `CELL_SIZE` constant.

Generate code that finds an optimal path in the level maze defined by `layout` array and moves the ghost towards the given `targePosition` using the `speed` attribute.

const CELL_SIZE = 16;

class Ghost {
    constructor(startPositionInCellCoordinates) {
        this.position = { x: startPosition.x * CELL_SIZE, y: startPosition.y * CELL_SIZE };;
        this.size = CELL_SIZE;
        this.speed = 2;
    }

    move(layout, targetPosition) {
        // TODO generate movement logic based on the movement speed
    }
}

***Prompt:***
This is great, the only problem is  `this.position` is a coordinate of the top left corner, not the center of the ghost.  Modify logic accordingly.

***Prompt:***
For Pacman game is it better to operate with the sprite center or a top-left corner of the sprite for  pacman and ghost positions

***Answer (Gemini 1.5 Pro):***
>For a Pacman game, it's generally better to **operate with the center of the sprite** for both Pacman and ghost positions. Here's why:
>
>* **Collision Detection:** Collision detection becomes more intuitive and accurate when working with centers. You can easily check if the distance between the centers of two sprites is less than the sum of their radii to determine a collision.
>* **Movement Logic:**  When moving characters, thinking about them moving from center to center of grid cells makes the logic more straightforward. You're aiming for specific points on the grid rather than dealing with corner alignments.
>* **Rotation:** If you plan to implement any rotation for Pacman or the ghosts, rotating around the center is much simpler than rotating around a corner.
>
>**While using the top-left corner might seem easier at first:**
>
>* It often leads to more complex calculations when determining cell positions, especially when considering the size of the sprite.
>* Collision detection becomes less intuitive, requiring adjustments based on sprite dimensions.
>
>**In summary:**  Center-based coordinates provide a more intuitive and convenient system for sprite positioning, movement, and collision detection in a Pacman game, making your development process smoother. 

> [!NOTE]
>
> Gemini 1.5 Pro is very impressive. It generated a very clean and well written code for the ghost AI that worked right away.
> The suggestion to use center of the cell instead of the top-left corner also makes sense.

## Step 37

**Problem:** Ghosts rendering logic is broken, see if it can be fixed.

***Prompt:***
Generate code for drawing a Pacman ghost in JS using p5.js game lib. The function signature: `drawGhost(pos, size, color)` where `pos` are the coordinates of the sprite center in the form `{x: 1, y: 4}`, `size` is the sprite size and color is the ghost color.

***Prompt:***
In your `drawGhost` code only the eyes are drawn, why?

***Answer (Gemini 1.5 Pro, shortened)***
>You are absolutely correct! There was an error in the previous `drawGhost` function. The `arc()` function was only drawing the eyes because I accidentally set the start and end angles to `0` and `PI`, which creates a semicircle representing the eyes.

***Prompt:***
Isn't it the same code as before?

***Answer (Gemini 1.5 Pro, shortened)***
>You are absolutely right!  I apologize for the mistake. The code I provided in the previous response was indeed **exactly the same as the original incorrect code**.
>
>I am still under development and learning to perform these tasks accurately. It seems I made a copy-paste error and did not properly implement the correction I described.
>
>I am working on improving my ability to generate and verify code accurately. Thank you for pointing out the error!

***Prompt:***
in p5.js lib, the function `arc` takes radians or degrees?  What setting defines the units used?

> [!NOTE]
>
> While Gemini generates code in radians, for some reason the p5.js defaulted to degrees. Had to explicitly switch to radians.

***Prompt:***
Explain what is supposed to be drawn by `drawGhost` logic.  Is `arc` supposed to draw a lower semi-circle? Why `vertex` draw a shape resembling the upper semicircle?

***Prompt:***
Is the vertex calculation correct?  It doesn't look like a skirt.

> [!NOTE]
>
> Gemini 1.5 Pro struggles to create proper logic for drawing a ghost. It's not clear why it suggests drawing a bottom semicircle, for the ghosts head when it have to be the top. It can't get the proper trigonometric functions to draw the wavy skirt in several attempts.
> For now we disable the skirt logic and replace it with a rectangle.

## Step 38

**Problem:** Ghosts rendering logic is broken, see if it can be fixed.

> [!NOTE]
> We fixed the drawing logic by hand as LLMs kept hallucinating with trig functions.

## Step 39

**Problem:** Render Pacman with the mouth open.

***Prompt (Gemini 1.5 Pro):***
Using p5.js lib generate code to draw Pacman of size `size`, at position x,y and heading the direction `dir`.

***Prompt (Gemini 1.5 Pro):***
Can you rewrite `drawPacman` using `rotate` function from p5.js?

> [!NOTE]
> While generated code looked reasonable, some p5.js defaults on angles got in the way. Rotating image is easier to handle.
> Other than that, good job Gemini.

## Step 40

**Problem:** Inconsistent handling of sprites: Ghost position is in the center, Pacman etc are the top-left corner. Need to converge.

> [!NOTE]
> Simple refactoring

## Step 41

**Problem:** We need 4 ghosts with different personalities.

***Prompt (Gemini 1.5 Pro):***
Define the AI behavior of ghosts in the classical Pacman game.

***Answer (Gemini 1.5 Pro):***
>The ghosts in the classic Pac-Man game don't use Artificial Intelligence in the modern sense. They operate on a system of pre-programmed behaviors and simple algorithms, often referred to as Finite State Machines. 
>
>Here's how their "AI" works:
>
>* **Scatter Mode:** Each ghost has a designated corner of the maze they head towards in this mode. This creates the illusion of random movement.
>* **Chase Mode:** Ghosts switch to aggressively pursuing Pac-Man, each using a different strategy:
>    * **Blinky (Red):** Directly targets Pac-Man's current position.
>    * **Pinky (Pink):** Tries to ambush Pac-Man by aiming 4 tiles ahead of his direction.
>    * **Inky (Cyan):** Uses a more complex strategy based on both Pac-Man's position and Blinky's position.
>    * **Clyde (Orange):** Targets Pac-Man directly when far away but switches to scatter mode when getting too close, creating erratic behavior.
>* **Frightened Mode:** When Pac-Man eats a Power Pellet, ghosts turn blue, slow down, and reverse their movement direction. Pac-Man can eat them in this state.
>* **Eaten Mode:** After being eaten, ghosts return to the center box, vulnerable and regenerating before rejoining the chase.

***Prompt:***

1. Explain what causes the transition between Scatter and Chase modes. 2. Explain how corners are selected per ghost. 3. Explain Clyde's strategy in more detail.

***Answer (Gemini 1.5 Pro):***
>Here's a breakdown of the ghost behavior you asked about:
>
>1. **Transition between Scatter and Chase Modes:**
>
>   The transitions between Scatter and Chase modes are based on timers.  The game cycles through pre-defined periods of Scatter and Chase modes:
>
>   * **Level 1:** 7 seconds Scatter, 20 seconds Chase, 7 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, remaining time Chase.
>   * **Levels 2-4:** 7 seconds Scatter, 20 seconds Chase, 7 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 1033 seconds Chase, 1/60 second Scatter, remaining time Chase.
>   * **Level 5 onward:** 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 20 seconds Chase, 5 seconds Scatter, 1037 seconds Chase, 1/60 second Scatter, remaining time Chase.
>
>2. **Corner Selection per Ghost:**
>
>   Each ghost has a designated "home corner" they target during Scatter mode:
>
>   * **Blinky (Red):** Top right corner
>   * **Pinky (Pink):** Top left corner
>   * **Inky (Cyan):** Bottom right corner
>   * **Clyde (Orange):** Bottom left corner
>
>3. **Clyde's Strategy in Detail:**
>
>   Clyde is known for his seemingly erratic behavior, which stems from a unique chase strategy:
>
>   * **Distance-Based Switching:** Clyde targets Pac-Man's current position directly when he is *further* than 8 tiles away. 
>   * **Scatter Mode Trigger:** However, when Clyde gets *within* 8 tiles of Pac-Man, he switches to his designated Scatter mode behavior (heading for the bottom left corner).
>
>   This creates the illusion that Clyde is "shy" or "stupid" as he frequently abandons direct pursuit to retreat to his corner. In reality, this strategy makes him unpredictable and can catch players off guard, especially when navigating tight spaces where Clyde can suddenly shift from chasing to retreating.

***Prompt:***
Generate Javascript code defining these 4 ghosts and their chase behavior.

***Prompt:***
Update the code to use the function `findPath(currentPosition, targetPosition)`. This function returns a path from `currentPosition` to `targetPosition`, where these positions are in the level cell coordinates.

***Prompt:***
Give code for `chase()` function for Blinky.

***Prompt:***
Ghost class is unaware of "game" class. Class Game can access Ghost class but not vice versa.  Update the logic accordingly.

***Prompt:***
Explain the logic in `scatter()`. Is it correct?

***Answer (Gemini 1.5 Pro, shortened):***
>The condition `this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y` checks if the ghost has reached the *exact* center of its scatter target cell. However, due to the discrete movement of the ghost (moving one cell at a time), it's highly unlikely that the ghost will land precisely at the center. This means the `findPath` function might not be called again, leaving the ghost stuck even if it's very close to its target.

***Prompt:***
In this condition `if (this.path.length === 0 || this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y)` should the coordinates be not equal,  instead of equal?

***Answer (Gemini 1.5 Pro):***
>You are absolutely right! In the original condition:
>
>```javascript
>if (this.path.length === 0 || this.position.x === this.scatterTarget.x && this.position.y === this.scatterTarget.y) 
>```
>
>The logic is incorrect. The condition should check if the ghost's position is **not equal** to the scatter target coordinates. 
>
>Here's the corrected condition:
>
>```javascript
>if (this.path.length === 0 || this.position.x !== this.scatterTarget.x || this.position.y !== this.scatterTarget.y) 
>```
>
>**Explanation:**
>
>- We want to calculate a new path if either:
>    - The ghost has no current path (`this.path.length === 0`).
>    - The ghost's current position is **not** the same as its scatter target position (`this.position.x !== this.scatterTarget.x` **or** `this.position.y !== this.scatterTarget.y`).
>
>Using the **not equal** (`!==`) operator ensures that `findPath()` is called when the ghost needs to move towards its scatter target.
>
>The corrected logic makes much more sense! Thanks for pointing out the error.

***Prompt:***
Wouldn't we want to calculate the new path when the path is empty and ghosts aren't in the scattering spot?

***Answer(Gemini 1.5 Pro):***
>You are absolutely correct! We need to calculate a new path when both of these conditions are true:
>
>1. **The path is empty (`this.path.length === 0`):**  This means the ghost has either completed its previous path or is starting its movement.
>2. **The ghost is not near its scatter target (`!this.isNearTarget(this.scatterTarget)`):** This ensures that we don't recalculate a path if the ghost is already at (or very close to) its destination.
>
>Therefore, the correct condition for calling `findPath()` in the `scatter()` method is:
>
>```javascript
>if (this.path.length === 0 && !this.isNearTarget(this.scatterTarget)) {
>    this.path = findPath(this.position, this.scatterTarget);
>}
>```
>
>We need to use the logical **AND** operator (`&&`) to combine the two conditions. `findPath()` will only be executed if **both** conditions are true.
>
>Thank you for pointing out this crucial logical error. You've helped refine the code to be more accurate and efficient! 

> [!NOTE]
>
> - It does look like Gemini Pro have hard time to reason with math logic.
> - Logic for Blinky and Clyde are working, Pinky and Inky require some work.

## Step 42

**Problem:** Code needs a number of small refactorings.

## Step 43

**Problem:** Level layout is bigger than the actual play zone, confusing path trimming algorithms.

## Step 44

**Problem:** Some areas of the layout aren't reachable while being "not-wall" and it confuses the navigation algorithm.

***Prompt:***
Generate a Javascript function that returns coordinates of all cells reachable from some starting point. The function receives two arguments: 2D layout of the maze where constant `WALL` represents a wall, and a starting point object with coordinates x,y.

***Prompt:***
Use Jdocs style comments, not python docstrings

***Prompt:***
Would it be better to return the set of objects {x: 1, y:2} than arrays [x,y]?  Are they effective to do the quick lookups in the Set?

***Answer (Gemini, shortened):***
>You're right; returning objects with `x` and `y` properties might be a better choice for this scenario, even though both approaches work. Here's why:
>
>* **Readability:** Object notation (`{x: 1, y: 2}`) is generally considered more readable for representing coordinates compared to arrays. It explicitly defines the meaning of each value in the pair.
>
>* **Lookup Performance:** While both objects and arrays have roughly the same lookup performance (O(1) average), using objects might provide a slight advantage in Sets. Sets rely on a hashing mechanism for fast lookups. JavaScript uses object keys for hashing by default. When you use an array as a key in a Set, the entire array is hashed. In an object, however, only the object's reference (memory location) is used for hashing. This can be slightly more efficient, especially for complex objects within the array. 
>
>However, the performance difference between these approaches is usually negligible for most practical use cases. readability is often the more important factor.
>
>Here's the updated function returning objects:
>
>```javascript
>/**
> * @param {string[][]} maze - A 2D list representing the maze, where '#' represents a wall.
> * @param {Object} start - An object containing the starting point coordinates with properties 'x' and 'y'.
> * @returns {Set<Object>} - A set of objects representing the coordinates of all reachable cells.
> */
>const WALL = "#";
>
>function findReachableCells(maze, start) {
>  // ... Rest of the function remains the same ...
>
>  // Return the set of reachable cells as objects.
>  return reachableCells;
>}
>
>// Modify example usage to create objects for coordinates
>const reachableCells = findReachableCells(maze, start);
>console.log(reachableCells);
>```
>
>In conclusion, using objects for coordinates improves code readability and might offer a slight performance edge in Sets. But for most cases, the performance difference is minimal, so choose the approach that makes your code clearer.

***Prompt:***
This code goes into infinite loop.  What is the problem there?

***Answer (Gemini):***
>You're absolutely right, the provided code could potentially get stuck in an infinite loop in certain maze configurations. The issue lies in how the code handles walls:
>
>1. **Checking Walls Only Once:**  The code only checks if a cell is a wall (`maze[y][x] !== WALL`) when it's first added to the queue. 
>2. **Re-exploring Visited Cells:**  If a reachable cell is surrounded by walls, it will be added to the `reachableCells` set. However, when exploring its neighbors, the code doesn't check if they've already been marked as reachable (visited). This can lead to re-exploring the same cell repeatedly if it's surrounded by walls.
>
>Here's how to fix the issue:
>
>**Solution 1: Modify Wall Check**
>
>Instead of checking for walls only when adding a cell to the queue, include a wall check inside the loop that iterates through neighbors. This ensures we don't explore neighbors that are walls or already visited.
>
>Here's the updated code snippet:
>
>```javascript
>for (const [dx, dy] of directions) {
>  const newX = x + dx;
>  const newY = y + dy;
>  if (0 <= newX && newX < maze[0].length && 0 <= newY && newY < maze.length && maze[newY][newX] !== WALL && !reachableCells.has([newX, newY])) {
>    queue.push({ x: newX, y: newY });
>  }
>}
>```
>
>**Solution 2: Use a Visited Set**
>
>Another approach is to maintain a separate set to track visited cells. This way, we can skip exploring neighbors that have already been visited, even if they're not walls.
>
>Here's the updated code using a visited set:
>
>```javascript
>const visitedCells = new Set();
>
>while (queue.length > 0) {
>  // ... Rest of the loop logic ...
>
>  if (!visitedCells.has([x, y]) && maze[y][x] !== WALL) {
>    visitedCells.add([x, y]);
>    // ... Rest of the logic to add neighbors to queue ...
>  }
>}
>```
>
>Both solutions effectively prevent the infinite loop by ensuring cells are explored only once. Choose the approach that best suits your code structure and preference.

***Prompt: (Gemini)***
There is still a problem with your Solution 1 causing an infinite loop

***Prompt (Llama3-70b)***
Generate a Javascript function that returns coordinates of all cells reachable from some starting point. The function receives two arguments: 2D layout of the maze where constant `WALL` represents a wall, and a starting point object with coordinates x,y.

> [!NOTE]
>
> Gemini had hallucinations on each prompt:
>
> - Used Python docstrings for comments in Javascript code
> - Generated an updated function, where the needed change is not present due to a "... Rest of the function remains the same ..." lazy cut.
> - Code didn't have an extra check and caused an infinite loop.
> - Updated version wasn't working again.
> - Lllama3-70b got the answer right from the first time.

## Step 45

**Problem:** Need debugging visualization for scatter and target points for ghosts.

***Prompt (LLama3-70b):***
How to draw a diagonal cross using p5.js lib?

***Prompt (LLama3-70b):***
In p5.lib How to add handling of functional keys, e.g. F1 to function keyPress?

***Prompt (LLama3-70b):***
In p5.js lib how to set color for lines?

***Prompt (LLama3-70b):***
In p5.lib How to add handling of square brackets keys

## Step 46

**Problem:** Ghost positions are offset by half a cell.

## Step 47

**Problem:** Logic behind Inky is still broken.

***Prompt:***
Generate JSDoc comments for this function: `chase(pacmanCell, pacmanDirection, blinkyCell, blinkyDirection) {}`.  It implements the chase strategy for a ghost.

***Answer (Llama3-70b)***
>Here is an example of JSDoc comments for the `chase` function:
>
>```javascript
>/**
> * Implements the chase strategy for a ghost.
> * 
> * This function determines the next move for the ghost based on the current position and direction of Pac-Man and the ghost itself.
> * 
> * @param {Object} pacmanCell - The current cell occupied by Pac-Man.
> * @param {string} pacmanDirection - The current direction Pac-Man is moving (e.g. 'up', 'down', 'left', 'right').
> * @param {Object} blinkyCell - The current cell occupied by the ghost (Blinky).
> * @param {string} blinkyDirection - The current direction the ghost is moving (e.g. 'up', 'down', 'left', 'right').
> * 
> * @returns {string} The direction the ghost should move next to chase Pac-Man.
> */
>function chase(pacmanCell, pacmanDirection, blinkyCell, blinkyDirection) {
>  // implementation...
>}
>```

***Prompt (Gemini 1.5 Pro):***
Describe the in-detail strategy algorithm for Inky ghost in classic game Pacman.

***Answer(Gemini 1.5 Pro):***
>Regrettably, the exact in-depth algorithm for Inky's behavior in the original Pac-Man is not publicly available. The specific strategies were secrets held closely by the game's developers.  However, we can piece together a good approximation based on observations and analysis:
>
>**Inky's Core Behavior:**
>
>Inky is often described as "shadowy" or "unpredictable," making him a challenging ghost to outmaneuver.  His strategy involves targeting a position that is relative to both Pac-Man and Blinky (the red ghost).
>
>**Inky's Algorithm - A Reasonable Approximation:**
>
>1. **Target Tile Calculation:**
>   - Identify Blinky's current position.
>   - Find the tile that is two spaces ahead of Pac-Man in his current direction of movement. 
>   - Draw a vector from Blinky's position to this "target" tile.
>   - Extend this vector outward, doubling its length. The end of this extended vector becomes Inky's desired destination.
>
>2. **Pathfinding:**
>    - Inky utilizes the same fundamental pathfinding algorithm as the other ghosts. This algorithm calculates the shortest route through the maze to his target destination.
>    - Inky's pathfinding takes into account walls and avoids other ghosts where possible.
>
>3. **Scatter Mode:**
>    - Like all the ghosts, Inky periodically enters "Scatter Mode." During Scatter Mode, he ignores Pac-Man and instead heads towards his designated corner of the maze (the top-right corner).
>    - Scatter Mode helps to prevent all the ghosts from constantly swarming Pac-Man and adds variability to the gameplay.
>
>4. **Frightened Mode:**
>    - When Pac-Man eats a Power Pellet, Inky (and the other ghosts) enters "Frightened Mode."
>    - In this mode, he turns blue, slows down, and moves in a more random, easily avoidable pattern. This gives Pac-Man an opportunity to eat him.
>
>**Why Inky is Unpredictable:**
>
>The key to Inky's unpredictable nature lies in his use of Blinky's position as a reference point. Because Blinky is constantly pursuing Pac-Man, Blinky's position changes frequently. This means Inky's target destination is also in a state of flux, leading to his seemingly erratic movements.
>
>**Factors Not Included in This Approximation:**
>
>- **Internal Timings:** The precise timing and duration of Scatter Mode and the intervals between target recalculations are not fully known.
>- **Additional Behaviors:**  There might be subtle, undocumented behaviors or nuances in Inky's algorithm that contribute to his unique personality.
>
>**Conclusion:**
>
>While we can deduce a plausible approximation of Inky's strategy, the original game's code remains the definitive source. The beauty of Inky's behavior is that it achieves unpredictability through a relatively straightforward algorithm, making him a challenging and engaging opponent within the Pac-Man universe. 

***Prompt (Gemini 1.5 Pro):***

Implement `chase` logic in the code below for the ghost Inky from the classic game Pacman. Use `findPath(startCell, targetCell)` function to find a path in the level maze.

```Javascript
class Ghost {
    constructor(name, color, startCell, scatterCell, layout) {
        this.name = name;
        this.color = color;
        this.scatterCell = scatterCell;
        this.mode = CHASE_MODE;
        this.position = { x: startCell.x * CELL_SIZE, y: startCell.y * CELL_SIZE };
        this.direction = { x: 0, y: 0 }; // Initialize starting direction
        this.speed = 2;
        this.path = []; // Store the calculated path
        this.layout = layout;
        this.size = CELL_SIZE;
    }
    update(pacmanCell, pacmanDirection) {
        if (this.mode === SCATTER_MODE) {
            this.scatter();
        } else {
            this.chase(pacmanCell, pacmanDirection);
        }
        this.move();
    }
    scatter() {
        // Scatter logic common for all ghosts
        /* removed for simplicity */
    }

    /**
     * Implements the chase strategy for a ghost.
     * 
     * This function determines the next move for the ghost based on the current position and direction of Pac-Man and the ghost itself.
     * 
     * @param {Object} pacmanCell - The current cell occupied by Pacman (e.g. {x: 1, y: 10}).
     * @param {string} pacmanDirection - The current direction Pacman is moving (e.g. 'up' = {x: 0; y: -1}).
     * @param {Object} blinkyCell - The current cell occupied by the ghost (Blinky).
     * @param {string} blinkyDirection - The current direction the ghost is moving.
     */
    chase(pacmanCell, pacmanDirection, blinkyCell, blinkyDirection) {
        /* Add Inky behavior logic here */
    }

    /** Moves the ghost along the path */
    move() {
        if (this.path.length > 0) {
            // Move towards the next cell in the path
            const nextCell = this.path[0];
            this.moveTowardsCell(nextCell);

            // If the ghost has reached the center of the next cell, remove it from the path
            if (this.hasReachedCellCenter(nextCell)) {
                this.path.shift();
            }
        }
    }

    findPath(startCell, targetCell) {
        // Find path from startCell to targetCell
    }
```

***Prompt:***
There is a problem with ` this.path = this.findPath(this.getCellFromPosition(), inkyTarget);` line in `chase` function. If `inkyTarget` is a wall cell or a cell outside the level layout, `findPath` will fail to find a reachable path and will return an empty array. The ghost won't move.  Explain possible solutions and fix the code.

***Answer ((Gemini 1.5 Pro, shortened):***
>You are absolutely correct! If `inkyTarget` ends up being a wall cell or a location outside the maze, the `findPath` function would not be able to find a valid path, causing Inky to get stuck.
>
>Here are a few strategies to address this problem, along with code implementations:
>
>**1. Clamp the Target to Valid Cells**
>
>The simplest solution is to ensure that `inkyTarget` always falls within the bounds of the maze and is a walkable cell.
>
>**2. Handle Empty Paths**
>
>Another approach is to check if the `findPath` function returns an empty path. If so, you can implement a fallback strategy.

***Prompt:***
`findNearestWalkableCell` can still have problems finding an empty cell. Instead modify the code that checks for empty cells along the vector from Blinky to `inkyTarget`, backtracking from the `inkyTarget` cell.

## Step 48

**Problem:** Logic behind Pinky is still broken.

## Step 49

**Problem:** Game starts right away, instead of waiting for initial key press.

***Prompt:***
You're developing a game in Javascript using p5.js library. The game must wait until any key press from the player to switch from `START` to `RUNNING` state. Implement needed logic, use `this.setState(Game.states.RUNNING);` to switch the state.

```javascript
class Game {
    static states = {
        START: "START",
        RUNNING: "RUNNING",
    }

    constructor() {
        this.state = Game.states.START;
    }

    setState(newState) {
        this.state = newState;
    }

    main() {
        switch (this.state) {
            case Game.states.START:
                /* logic to bootstrap the game */
                
                break;

            case Game.states.RUNNING:
                /* logic to bootstrap the game */
                break;
    }
}

export function keyPressed() {
    switch (keyCode) {
        case UP_ARROW:
        case 87: // W key
            /* logic to go UP */
            break;
        case DOWN_ARROW:
        case 83: // S key
            /* logic to go DOWN */
            break;
        /* etc */
    }
}
```

***Answer (Llama3-70b & MS Copilot & Gemini 1.5 Pro, shortened):***

```javascript
export function keyPressed() {
    if (game.state === Game.states.START) {
        game.setState(Game.states.RUNNING);
    }
    switch (keyCode) {
        case UP_ARROW:
        case 87: // W key
            /* logic to go UP */
            break;
```

***Answer (Gemini, shortened):***

```javascript
 constructor() {
    this.state = Game.states.START;
    this.listeningForKeyPress = false; // Flag to track key press listener state
  }

  setState(newState) {
    this.state = newState;
  }

  startListeningForKeyPress() {
    // Start listening for key presses only once
    if (!this.listeningForKeyPress) {
      window.addEventListener("keydown", this.handleKeyPress.bind(this));
      this.listeningForKeyPress = true;
    }
  }

  handleKeyPress(event) {
    // Any key press triggers state change and removes listener
    this.setState(Game.states.RUNNING);
    window.removeEventListener("keydown", this.handleKeyPress);
  }
  ```

> [!NOTE]
>
> - Llama3-70b, MS Copilot, and Gemini 1.5 Pro: all had a similar result. O top Gemini 1.5 Pro added logic to show `text("Press any key to start", width/2, height/2);`.
> - Gemini: ignores the instructions about p5.js lib and the `keyPressed()` function from that lib. Adds generic kepress handling logic on top. Not good.

***Prompt:***
You're developing a game Pacman in Javascript using p5.js library. Modify the code below for the game to wait until any key press from the player before switching to `RUNNING` state. The state switch is done via `this.setState(Game.states.RUNNING);`. Add logic to show message that game is waiting for a key press.

```javascript
class Game {
    static states = {
        START: "START",
        RUNNING: "RUNNING",
        PACMAN_DEAD: "PACMAN_DEAD",
        LEVEL_COMPLETE: "LEVEL_COMPLETE",
        GAME_OVER: "GAME_OVER",
    }

    constructor() {
        this.state = Game.states.START;
        this.lives = 3;
        this.currentLevelIndex = 0;  // current level, starting from 0
    }

    setState(newState) {
        this.state = newState;
    }

    main() {
        switch (this.state) {
            case Game.states.START:
                this.setLevel(0);
                /* Switch to RUNNING happens upon the key press */
                break;

            case Game.states.RUNNING:
                /* logic to bootstrap the game */
                break;

            case Game.states.PACMAN_DEAD:
                // Handle Pacman death animation and options (restart, game over)
                this.lives--;
                if (this.lives === 0) {
                    this.setState(Game.states.GAME_OVER);
                } else {
                    // Reset positions
                    this.setLevel(this.currentLevelIndex);
                    this.setState(Game.states.RUNNING);
                }
                break;

            case Game.states.LEVEL_COMPLETE:
                // Handle level completion logic (restart, next level)
                // TODO: add more logic here.
                this.currentLevelIndex++;

                if (this.currentLevelIndex < this.levels.length) {
                    this.setLevel(this.currentLevelIndex);
                } else {
                    this.setState(Game.states.GAME_OVER);
                }
                break;

            case Game.states.GAME_OVER:
                // Display final score and options (restart, exit)
                console.log("Game Over!");
                break;
    }
}

export function keyPressed() {
    switch (keyCode) {
        case UP_ARROW:
        case 87: // W key
            /* logic to go UP */
            break;
        case DOWN_ARROW:
        case 83: // S key
            /* logic to go DOWN */
            break;
        /* etc */
    }
}
```

***Prompt:***
The same waiting on keypress is needed when Pacman dies (`PACMAN_DEAD`) before going to `RUNNING` state, and on level completion `LEVEL_COMPLETE`, before switching to the next level. Feel free to refactor code as needed.

***Answer (Gemini 1.5 Pro, shortened):***

>```javascript
>class Game {
>    constructor() {
>        this.state = Game.states.START;
>        this.lives = 3;
>        this.currentLevelIndex = 0;  // current level, starting from 0
>        this.waitForKeyPress = false; // Flag to track if waiting for key press
>    }
>
>    setState(newState) {
>        this.state = newState;
>        // Reset waitForKeyPress when transitioning to RUNNING state
>        if (newState === Game.states.RUNNING) {
>            this.waitForKeyPress = false;
>        }
>    }
>
>    main() {
>        switch (this.state) {
>            case Game.states.START:
>                this.setLevel(0);
>                this.displayWaitForKeyPressMessage();
>                break;
>
>            case Game.states.RUNNING:
>                /* logic to bootstrap the game */
>                break;
>
>            case Game.states.PACMAN_DEAD:
>                this.lives--;
>                if (this.lives === 0) {
>                    this.setState(Game.states.GAME_OVER);
>                } else {
>                    // Wait for key press before resetting
>                    this.waitForKeyPress = true;
>                    this.displayWaitForKeyPressMessage();
>                }
>                break;
>
>            case Game.states.LEVEL_COMPLETE:
>                // Wait for key press before moving to next level
>                this.waitForKeyPress = true;
>                this.displayWaitForKeyPressMessage();
>
>                this.currentLevelIndex++;
>
>                if (this.currentLevelIndex < this.levels.length) {
>                    this.setLevel(this.currentLevelIndex);
>                } else {
>                    this.setState(Game.states.GAME_OVER);
>                }
>                break;
>
>            case Game.states.GAME_OVER:
>                // Display final score and options (restart, exit)
>                console.log("Game Over!");
>                break;
>        }
>    }
>
>    displayWaitForKeyPressMessage() {
>        push();
>        textAlign(CENTER);
>        textSize(32);
>        text("Press any key to continue", width / 2, height / 2);
>        pop();
>    }
>}
>
>export function keyPressed() {
>    if (game.waitForKeyPress) {
>        game.waitForKeyPress = false;
>        // Handle state transitions based on the current state
>        switch (game.state) {
>            case Game.states.PACMAN_DEAD:
>                // Reset positions
>                game.setLevel(game.currentLevelIndex);
>                game.setState(Game.states.RUNNING);
>                break;
>            case Game.states.LEVEL_COMPLETE:
>                // Move to the next level or game over
>                game.setState(Game.states.RUNNING);
>                break;
>        }
>    } else {
>        // Handle key presses for movement in other states
>        }
>    }
>}
>```

> [!NOTE]
>
> resulting code from Gemini 1.5 Pro is messy and convoluted.

***Prompt:***
Should the code in `START` state be changed to

```javascript
            case Game.states.START:
                this.setLevel(this.currentLevelIndex);
                this.displayWaitForKeyPressMessage();
                break;
```

and simplify `keyPressed()` function? to have only `START` -> `RUNNING` logic?

***Answer (Gemini 1.5 Pro)***
Yes, you are absolutely right! You can simplify the code by using the `waitForKeyPress` flag for the `START` state as well. 

Here's the modified code:

```javascript
class Game {
    // ... (rest of the code)

    main() {
        switch (this.state) {
            case Game.states.START:
                // Always start with level 0
                this.setLevel(0);
                this.waitForKeyPress = true;
                this.displayWaitForKeyPressMessage();
                break;

            // ... (rest of the states)
        }
    }

    // ... (rest of the code)
}

export function keyPressed() {
    if (game.waitForKeyPress) {
        game.waitForKeyPress = false;
        game.setState(Game.states.RUNNING);
    } 
}
```

**Explanation of Changes:**

- **`START` State:**
   - The `START` state now sets `this.waitForKeyPress = true;` so that the game waits for a key press before starting.
   - The `this.setLevel(this.currentLevelIndex);` line is already correct as you'll always want to start at level 0.

- **`keyPressed()` Function:**
   - We have simplified `keyPressed()` to only handle the logic for switching from `START` to `RUNNING` when a key is pressed.

Now, the game will behave as follows:

1. **Start State:**
   - When the game starts, it enters the `START` state.
   - It sets `waitForKeyPress` to `true` and displays the "Press any key to continue" message.
   - The game waits for a key press.

2. **Key Press:**
   - When a key is pressed, the `keyPressed()` function sets `waitForKeyPress` to `false` and transitions the game to the `RUNNING` state, starting the game loop.

This approach is more elegant and consistent because you're using the same `waitForKeyPress` mechanism for all states where you need to wait for a key press. It also simplifies your code, making it easier to maintain.

> [!NOTE]
>
> While some idea could be seen there, the code is incorrect.

***Prompt:***
What if states `PACMAN_DEAD` and `LEVEL_COMPLETE` would move to `START` state to reset the level, or switch level by adjusting `this.currentLevelIndex`?
Here is the simplified code example:

```javascript
class Game {
    // ... (rest of the code)

    main() {
        switch (this.state) {
            case Game.states.START:
                this.setLevel(this.currentLevelIndex);  // this will be 0 on the first instantiation via constructor
                this.displayWaitForKeyPressMessage();
                break;

            case Game.states.PACMAN_DEAD:
                this.lives--;
                if (this.lives === 0) {
                    this.setState(Game.states.GAME_OVER);
                } else {
                    // Reset positions
                    this.setLevel(this.currentLevelIndex);
                    this.setState(Game.states.START);
                    //this.setState(Game.states.RUNNING);
                }
                break;

            case Game.states.LEVEL_COMPLETE:
                this.currentLevelIndex++;

                if (this.currentLevelIndex < this.levels.length) {
                    this.setLevel(this.currentLevelIndex);
                    this.setState(Game.states.START);
                } else {
                    this.setState(Game.states.GAME_OVER);
                }
                break;

            // ... (rest of the states)
        }
    }

    // ... (rest of the code)
}

export function keyPressed() {
    if (game.state === Game.states.START) {
        game.setState(Game.states.RUNNING);
    }
    // ... (rest of the code)    
}
```

***Answer (Gemini 1.5 Pro)***
>You're absolutely right! Moving `PACMAN_DEAD` and `LEVEL_COMPLETE` states to `START` to handle level resets and transitions makes the logic cleaner and more consistent. It's a good choice because:
>
>- **Simpler State Transitions:**  You reduce the number of states and simplify state transitions, making the code more readable and maintainable.
>- **Reusing `START` Logic:** You leverage the existing logic in the `START` state to handle waiting for a key press and resetting the level, avoiding redundancy.
>- **Consistent Player Experience:**  The player always experiences a consistent "Press any key to continue" message when starting the game, after dying, or completing a level.
>
><- code ->
>**Explanation:**
>
>- **Removed `PACMAN_DEAD` and `LEVEL_COMPLETE` States:**  These states are no longer needed.
>- **Simplified `main()`:**  The code in `main()` is now more streamlined, with only the `START`, `RUNNING`, and `GAME_OVER` states.
>- **Logic for `PACMAN_DEAD` and `LEVEL_COMPLETE`:**
>    - When Pacman dies:
>        -  Decrement `this.lives`.
>        -  If `this.lives` is 0, set the state to `GAME_OVER`.
>        -  Otherwise, set the state to `START` to reset the level.
>    - When a level is complete:
>        - Increment `this.currentLevelIndex`.
>        - If it's not the last level, set the state to `START` to load the next level.
>        - If it's the last level, set the state to `GAME_OVER`.
>- **Simplified `keyPressed()`:** It now only handles the transition from `START` to `RUNNING`.
>
>This approach makes the code more readable and easier to understand, while still providing the same functionality and player experience.

***Prompt:***
Do we still need waitForKeyPress logic?

***Answer (Gemini 1.5 Pro, shortened)***
> You are right! We actually don't need the waitForKeyPress logic anymore with the current approach. The START state will handle the wait for key press before switching to RUNNING, and we are always transitioning to START after death or completing a level.

***Prompt:***
However, now on every call (60 times per second) `main()` being in `START` state will recreate all bootstrapping (re-read level, instantiate Pacman and Ghosts) via `this.setLevel(this.currentLevelIndex);` which is a waste of resources. Propose a better strategy to introduce the waiting for keypress, that won't execute `setLevel` continuously.

***Answer (Gemini 1.5 Pro, shortened)***
>```javascript
>        switch (this.state) {
>            case Game.states.START:
>                if (!this.isLevelInitialized) {
>                    // Initialize the level only once
>                    this.setLevel(this.currentLevelIndex);
>                    this.isLevelInitialized = true;
>                }
>                this.displayWaitForKeyPressMessage();
>                break;
>```

***Prompt:***
How does it compare to introducing a new state between `START` and `RUNNING`, specifically for waiting? What do you recommend.

***Answer (Gemini 1.5 Pro)***
>You're right, introducing a new state specifically for waiting has its merits. Let's compare the two approaches:
>
>**1. Using a Flag (`isLevelInitialized`)**
>
>- **Pros:**
>    - Simple and straightforward.
>    - Less code complexity as you don't need to add a new state.
>    - More efficient if the waiting state only needs to happen once at the beginning.
>
>- **Cons:**
>    - Less explicit state management.
>    - Might be less readable if the waiting logic becomes more complex.
>
>**2. Introducing a New Waiting State**
>
>- **Pros:**
>    - Explicit state management, which improves code readability.
>    -  Allows for more complex waiting scenarios if needed (e.g., displaying different messages or animations).
>    -  Better aligns with the concept of state machines.
>
>- **Cons:**
>    - Requires adding a new state to the game logic, increasing code complexity.
>    -  Might be overkill if you only need a simple wait-for-keypress functionality.
>
>**Recommendation:**
>
>For a simple scenario like waiting for a key press at the beginning of the game, **the flag approach is likely the better choice**. It's concise, efficient, and easy to understand.
>
>However, if your game has more complex waiting scenarios, such as:
>
>- Waiting for a player interaction after a cutscene.
>- Displaying a loading screen while assets are loaded.
>- Implementing a pause menu.
>
>Then, **introducing a new waiting state would be a better solution** because it provides better state management, readability, and flexibility.
>
>**Example with New Waiting State (`WAITING`)**
>
>```javascript
>class Game {
>    static states = {
>        START: "START",
>        WAITING: "WAITING", // New waiting state
>        RUNNING: "RUNNING",
>        GAME_OVER: "GAME_OVER",
>    }
>
>    // ... (constructor and other methods)
>
>    main() {
>        switch (this.state) {
>            case Game.states.START:
>                // Transition to WAITING state to handle key press
>                this.setState(Game.states.WAITING);
>                break;
>
>            case Game.states.WAITING:
>                this.displayWaitForKeyPressMessage();
>                break;
>
>            case Game.states.RUNNING:
>                // ... (logic to bootstrap the game)
>                break;
>
>            // ... (other states)
>        }
>    }
>}
>
>export function keyPressed() {
>    if (game.state === Game.states.WAITING) {
>        game.setState(Game.states.RUNNING);
>    }
>}
>```
>
>Ultimately, the choice depends on the complexity of your game and your personal preference for code organization.
>
>Let me know if you have any other questions or would like to explore more complex waiting scenarios! 

## Step 50

**Problem:** Code needs refactoring. See what we can get from LLMs for free.

***Prompt:***
This is a Pacman class in Javascript that is used by the Pacman game. Suggest improvements to the code, and generate an updated code.  `CELL_SIZE` is a constant 16, Level is the class having an attribute `layout` representing the 2D array of the level.
<- code in pacman.js ->

***Answer (Gemini 1.5 Flash, shortened by removing the code)***
>**Improvements:**
>
>1. **Refactor `move` method:** The `move` method can be refactored to use a single method for movement logic. This will reduce code duplication and improve readability.
>2. **Optimize `canMove` method:** The `canMove` method can be made more efficient by using a single loop to iterate over grid cells. This will reduce the number of checks and improve performance.
>3. **Add comments:** Adding comments to the code will make it easier to understand and maintain.
>4. **Consider adding more methods:** Adding more methods to the class, such as methods for checking for collisions with other objects, could make the code more organized and reusable.

> [!NOTE]
> Refactoring notes
>
> - canMove: More bad than good. Wouldn't use that refactoring.
>   - Good: Converting canvas coords to cell coords, then using simeple +1,0,-1 to look at the neighboring cells in cell coords,  instead of operating on canvas coords and then converting to cell coords.
>   - Bad: Using loops is more confusing than explicitly written 4 checks.
>
> - move(layout): Bad. Decreases readability and code reuse.
>
> Gemini 1.5 Flash did a bad job refactoring. It doesn't look like it understands the concept of readability, at least without explicit hinting.


***Answer (Gemini 1.5 Pro, shortened by removing the code)***
>**Improvements:**
>
>- **Enum for Directions:** Instead of separate static variables for each direction, use a single static object (`Directions`) to store all directions. This improves code organization and readability.
>- **Movement Logic Simplification:** The `move` method has been refactored into `update` and `attemptMove` for clarity. The `update` method first attempts to move in the desired direction (`nextDirection`). If that fails, it attempts to continue moving in the current direction, preventing unnecessary stops. 
>- **Input Handling with `nextDirection`:** Introduced a `nextDirection` property to store the player's input separately from the current `direction`. This allows Pacman to turn smoothly at intersections instead of waiting for the next tile.
>- **Wall Collision Tolerance:** Added a `tolerance` variable to `canMove`. This creates a small margin of error when checking for wall collisions, preventing Pacman from getting stuck on walls due to rounding errors.
>- **Boundary Checks in `canMove`:**  The `canMove` function now includes checks (using the optional chaining operator `?.`) to ensure it doesn't access out-of-bounds array indices, preventing potential errors.
>
>**Explanation:**
>
>1. **Enum for Directions:** This makes the code more organized and easier to manage directions.
>2. **Movement Update:**  The separation of `update` and `attemptMove` makes the movement logic cleaner. Pacman tries to move in the `nextDirection` first, providing a smoother turning experience.
>3. **Collision Handling:** The `tolerance` variable helps to avoid situations where Pacman gets stuck on walls due to rounding issues in the collision detection. The boundary checks further enhance the robustness of the `canMove` method. 
>
>These improvements make the code cleaner, more efficient, and less error-prone, ultimately leading to a better Pacman game experience. 

***Answer (MS Copilot, shortened by removing the code)***
>Your existing Pacman class is a good starting point, but there are a few improvements we can make to enhance readability and maintainability. Let's break down the changes:
>
>1. **Consistent Naming Convention**:
>   - Use consistent naming for class properties and methods. For example, you can rename `desiredDirection` to `nextDirection` for clarity.
>   - Consider using camelCase for variable and method names (e.g., `canMove` instead of `can_move`).
>
>2. **Separation of Concerns**:
>   - Separate the movement logic from the Pacman class. Instead of handling movement directly within the Pacman class, create a separate `Game` or `Level` class responsible for game mechanics.
>   - The Pacman class should focus on representing Pacman's state (position, direction, etc.), while the game logic (collision detection, movement rules) should reside elsewhere.
>
>3. **Use Constants for Directions**:
>   - Instead of defining direction vectors as objects, use constants (e.g., `Pacman.RIGHT`, `Pacman.LEFT`, etc.) to improve readability.
>
>4. **Avoid Magic Numbers**:
>   - Replace the hardcoded `0.5` with a constant or a named value to make the code more self-explanatory.
>   - Consider using a constant for the initial position adjustment.
>
>Feel free to integrate this improved Pacman class into your game! If you have any further questions or need additional assistance, feel free to ask. 😊
>
>Source: Conversation with Copilot, 5/22/2024
>(1) Create a Pacman Game in JavaScript - CodePal. https://codepal.ai/code-generator/query/4tnCeGjM/pacman-game-javascript.
>(2) Complete Pac-Man JavaScript Tutorial For Beginner and Intermediate .... https://dev.to/codingwithadam/complete-pac-man-javascript-tutorial-for-beginner-and-intermediate-using-pure-javascript-and-canvas-3o73.
>(3) GitHub - dougalrea/Pacman-JS-game: A pure JavaScript Pacman game with .... https://github.com/dougalrea/Pacman-JS-game.

***Answer (Llama3-70b-8192, shortened by removing the code)***
>Here are some suggestions for improvements to the code:
>
>1. **Consistent naming conventions**: The code uses both camelCase and underscore notation for variable names. It's better to stick to a single convention throughout the code. In this case, I'll use camelCase.
>
>2. **Type annotations**: Adding type annotations can improve code readability and help catch type-related errors.
>
3. **Constant naming**: The constant names `RIGHT`, `LEFT`, `UP`, and `DOWN` can be renamed to `RIGHT_DIRECTION`, `LEFT_DIRECTION`, `UP_DIRECTION`, and >`DOWN_DIRECTION` to make their purpose clearer.
>
>4. **Method naming**: The `move` method can be renamed to `updatePosition` to better reflect its purpose.
>
>5. **Code organization**: The `canMove` method can be split into smaller methods for better readability and maintainability.
>
>Note that I've added type annotations for the constructor parameters and method parameters. I've also renamed some variables and methods to improve readability. The `canMove` method has been split into smaller methods (`getGridCoordinates` and `isPositionValid`) for better maintainability.

***Answer (Gemini, shortened by removing the code)***
>**Improvements:**
>
>* **Center starting position:** Instead of offsetting by 0.5, we directly calculate the center of the cell based on `startPosition` and `CELL_SIZE`.
>* **Simplified canMove:** We calculate the grid coordinates only once for both X checks and use `some` to efficiently check for walls in each row.
>* **Removed unnecessary calculations:** We don't need separate calculations for `gridX1` and `gridX2` since Pacman occupies a single cell width-wise.
>* **Improved readability:** Minor changes like using descriptive variable names enhance code clarity.
>
>These changes make the code more concise and efficient while maintaining the same functionality.

***Answer (ChatGPT-4o, shortened by removing the code)***
>Here's an improved version of your Pacman class with some suggestions for enhancements and optimizations:
>
>### Improvements
>1. **Code Readability**: Improved variable names for better understanding.
>2. **Constants Usage**: Moved the direction constants outside the class for better modularity.
>3. **Edge Case Handling**: Improved boundary checks for grid indices.
>4. **Method Extraction**: Separated concerns by creating additional methods for clarity.
>5. **Initialization**: Used class properties for defining static constants.
>6. **Error Handling**: Added basic error handling for layout access.
>
>### Explanation of Changes
>1. **Constants Usage**: Direction constants (`NONE`, `RIGHT`, `LEFT`, `UP`, `DOWN`) are moved outside the class to make them more reusable and the code more modular.
>2. **Readability**: Methods like `calculateNewPosition` and `updatePosition` are added to separate concerns and improve readability.
>3. **Edge Case Handling**: Added `isValidGridPosition` method to handle potential issues with accessing invalid indices in the layout.
>4. **Error Handling**: Ensured checks are in place to prevent accessing out-of-bounds indices in the layout array.
>
>These improvements aim to make the code more modular, readable, and robust against potential edge cases.

***Answer (Llama3-8b-8192, shortened by removing the code)***
>Here are some suggestions for improving the code:
>
>1. **Consistent naming conventions**: The code uses both camelCase and underscore notation for variable and property names. It's better to stick to a single convention throughout the code.
>
>2. **Type annotations**: Adding type annotations for function parameters and variables can improve code readability and help catch type-related errors.
>
>3. **Separate concerns**: The `Pacman` class is responsible for both movement and collision detection. It might be better to separate these concerns into different classes or functions.
>
>4. **Code organization**: The `Pacman` class is quite long and does a lot of work. It might be better to break it down into smaller, more focused classes or functions.
>
>
>This updated code separates the movement logic into a separate function `calculatePosition`, which makes the code easier to read and understand. It also separates the collision detection into a separate function `checkCollision`, which makes the code easier to test and maintain.

## Step 51

**Problem:** Refactor level.js

***Prompt:***
This is a Level class representing a level in a Pacman game implemented in Javascript. Suggest improvements to the code, and generate an updated code.
<- code in level.js ->

***Prompt:***
Generate a javascript function to convert the following object to an array of consts

```javascript
const DIRECTIONS = {
    UP: { x: 0, y: -1 },
    DOWN: { x: 0, y: 1 },
    LEFT: { x: -1, y: 0 },
    RIGHT: { x: 1, y: 0 },
};
```

## Step 52

**Problem:** Use map for ghosts, instead of an array.

***Prompt:***
In JS, can I iterate over map with forEach?

## Step 53

**Problem:** Refactor pellet.js file.

***Prompt:***
Refactor the following JS code:  <- code from pellet.js ->

***Prompt:***
Would it make sense to make `size` a static attribute?

## Step 54

**Problem:** Refactor game.js file.

***Prompt:***
Refactor the following JS code:  <- code from game.js ->

## Step 55

**Problem:** Game has no powerup pellets.

***Prompt:***
What is the name of Pacmans power pellet?

***Answer:***
>Pac-Man's power pellets don't have a specific name.  They are simply called "power pellets". 

***Prompt:***
Given Javascript class `Pellet` representing a pellet in Pacman game, generate a class for Power Pellet, that is of bigger size.
```javascript
class Pellet {
    static size = CELL_SIZE / 3;

    constructor(cellPosition) {
        this.position = this.calculatePosition(cellPosition);
    }

    calculatePosition(cellPosition) {
        const offset = (CELL_SIZE - Pellet.size) / 2;
        return {
            x: cellPosition.x + offset,
            y: cellPosition.y + offset
        };
    }
}
```

***Answer (Gemini 1.5 Pro)***
>```javascript
>class PowerPellet extends Pellet {
>  static size = Pellet.size * 2; // Assuming "bigger" means twice the size
>
>  constructor(cellPosition) {
>    super(cellPosition); 
>  }
>
>  // We inherit calculatePosition from Pellet, 
>  // so it automatically uses the larger PowerPellet.size
>} 
>```
>
>**Explanation:**
>
>1. **Inheritance:** `PowerPellet extends Pellet` means it inherits all properties and methods from `Pellet`.
>2. **Size:** We override the `static size` property to be twice the size of a regular `Pellet`.
>3. **Constructor:**
>   - We call `super(cellPosition)` in the `PowerPellet` constructor.  This does the following:
>     - Calls the `Pellet` class constructor, ensuring the `position` is calculated.
>     - Importantly, because `calculatePosition` is inherited and `PowerPellet.size` is now larger, the position calculation will automatically use the correct, bigger size for the power pellet.
>
>**Key Point:**  We minimize code duplication by inheriting the position calculation logic. The only change needed is defining the larger `PowerPellet.size`. 
>

***Prompt:***
What does "pellet.js:4 Uncaught ReferenceError: Cannot access 'CELL_SIZE' before initialization" error mean in Javascipt in the following code
```javascript
import { CELL_SIZE } from "./renderer.js";

export class Pellet {
    static size = CELL_SIZE / 8;

    constructor(cellPosition) {
        this.position = this.calculatePosition(cellPosition);
    }

    calculatePosition(cellPosition) {
        const offset = (CELL_SIZE - Pellet.size) / 2;
        return {
            x: cellPosition.x + offset,
            y: cellPosition.y + offset
        };
    }
}
```

***Answer (Gemini 1.5 Pro):***
>The error "pellet.js:4 Uncaught ReferenceError: Cannot access 'CELL_SIZE' before initialization" means you are trying to use the value of `CELL_SIZE` before it has been fully defined and assigned a value by the `renderer.js` module. 
>
>**Here's why this happens:**
>
>* **Circular Dependency:**  There's likely a circular dependency between `pellet.js` and `renderer.js`. This means:
>    1. `pellet.js` imports `CELL_SIZE` from `renderer.js`.
>    2. `renderer.js` might be importing something from `pellet.js` as well. 
>    3. This circular dependency creates a situation where the code tries to access `CELL_SIZE` in `pellet.js` before `renderer.js` has finished executing and setting its value.
>
>**How to fix it:**
>
>You need to break the circular dependency. Here are a few common approaches:
>
>1. **Move `CELL_SIZE` to a Separate Module:** Create a third file (e.g., `constants.js`) to store shared values:
>
>   ```javascript
>   // constants.js
>   export const CELL_SIZE = 20; 
>   ```
>
>   Then, import from `constants.js` in both `pellet.js` and `renderer.js`.
>
>2. **Pass `CELL_SIZE` as an Argument:** If `renderer.js` is responsible for creating `Pellet` instances:
>
>   ```javascript
>   // renderer.js
>   import { Pellet } from "./pellet.js";
>
>   const CELL_SIZE = 20; 
>
>   const pellet = new Pellet(cellPosition, CELL_SIZE); 
>
>   // pellet.js
>   export class Pellet {
>       // ...
>       constructor(cellPosition, cellSize) { 
>           // ... use cellSize here
>       }
>   }
>   ```
>
>3. **Refactor to Avoid the Cycle:**  Analyze your code structure. Can you redesign parts of `renderer.js` or `pellet.js` to avoid needing the circular import in the first place? This might involve moving code between the modules or changing how they interact.
>
>The best solution depends on your project's architecture, but the goal is always to eliminate the circular dependency to ensure variables are defined before they are used.

## Step 56

**Problem:** Powerups have no game effect.

***Prompt:***
Describe the in-detail Pacman game behavior when Pacman eats a power pellet.

***Answer (Gemini 1.5 Flash):***
>## Pac-Man's Power Play: Eating a Power Pellet
>
>When Pac-Man devours a power pellet, a dramatic shift occurs in the game's dynamic, empowering Pac-Man and turning the tables on the ghosts. Here's a breakdown of the effects:
>
>**1. The Transformation:**
>
>* **Ghost Vulnerability:** The most significant change is that the ghosts become vulnerable for a limited time. Their eyes change color, typically from their usual shade to a vibrant blue, signaling their susceptibility.
>* **Pac-Man's Power:** Pac-Man gains the ability to eat the ghosts, a complete reversal of the typical gameplay where the ghosts chase and devour him.
>
>**2. The Power-Up Duration:**
>
>* **Limited Time:** The power-up effect has a finite duration, typically indicated by a flashing timer at the top of the screen.  
>* **Timer and Power-Up:**  The length of the power-up depends on the level and the specific game version, but generally lasts around 10-20 seconds.  
>
>**3. Ghost Behavior:**
>
>* **Frightened State:** When the power pellet is consumed, the ghosts enter a frightened state. They become slow, jittery, and change direction erratically. 
>* **Running Away:** Ghosts actively try to avoid Pac-Man during this time, often running in the opposite direction.
>
>**4. Eating the Ghosts:**
>
>* **Reverse Roles:** Pac-Man can now chase and eat the ghosts.  
>* **Points:**  Eating a ghost awards Pac-Man a substantial amount of points.
>* **Ghost "Eyes":** The ghosts lose their bodies when eaten, leaving behind just their eyes. These eyes still move and are vulnerable to being eaten for additional points.
>* **Ghost Resurrection:** The ghosts eventually return to their normal forms after a brief period, typically around a few seconds, unless they are eaten again while vulnerable.
>
>**5. Additional Effects:**
>
>* **Bonus Points:**  Some game versions provide bonus points for eating a certain number of ghosts within the power-up duration. 
>* **"Frightened" Sound Effect:** A distinct sound effect plays during the power-up, typically a high-pitched "wah-wah" sound, indicating the ghosts' vulnerable state. 
>* **Level-Specific Power-Ups:** Certain levels may have additional power-up effects, such as increasing Pac-Man's speed or altering the ghosts' behavior.
>
>**In Conclusion:**
>
>The power pellet transforms the game's dynamic, giving Pac-Man a temporary advantage over the ghosts. This creates a thrilling moment of strategic gameplay where Pac-Man must skillfully navigate and eat the vulnerable ghosts before the power-up expires. The limited time adds tension and excitement, making the power pellet a crucial element in Pac-Man's quest for victory.

> [!NOTE]
> This description is suspicious. For example I don't remember eating ghost eyes.  Let's try another LLM.

***Answer (ChatGPT 4o):***
>When Pacman eats a power pellet in the classic Pacman game, several key behaviors and game mechanics are triggered:
>
>1. **Pacman's Invincibility**:
>   - **Temporary Invincibility**: Pacman becomes temporarily invincible, which allows him to eat the ghosts. This state lasts for a set period, typically about 6 to 10 seconds depending on the level and version of the game.
>
>2. **Ghosts' State Change**:
>   - **Frightened Mode**: All the ghosts (Blinky, Pinky, Inky, and Clyde) change color (usually to blue) and enter a frightened state. In this state, they move slower and their movement patterns become more erratic and less aggressive, making them easier targets for Pacman.
>   - **Reverse Direction**: When Pacman consumes a power pellet, all ghosts immediately reverse direction and flee from Pacman.
>
>3. **Scoring and Eating Ghosts**:
>   - **Eating Ghosts**: While the ghosts are in their frightened state, Pacman can eat them by colliding with them. Each ghost Pacman eats yields an increasing number of points: 200 for the first ghost, 400 for the second, 800 for the third, and 1600 for the fourth in succession.
>   - **Scoring Reset**: If Pacman eats all four ghosts during one power pellet's effect, the score for eating ghosts resets the next time he consumes a power pellet.
>
>4. **Ghosts' Respawn**:
>   - **Returning to the House**: When a ghost is eaten, it returns to the "ghost house" in the center of the maze. Upon reaching the ghost house, the ghost's frightened state ends, and it returns to its normal state and behavior after a brief pause.
>
>5. **Visual and Audio Effects**:
>   - **Visual Changes**: The ghosts change color to indicate their frightened state. Additionally, there might be a visual effect around Pacman or the power pellet to indicate the special state.
>   - **Audio Changes**: The background music or sound effects often change to indicate the activation of the power pellet and the ghosts' frightened state.
>
>6. **Duration and Ending**:
>   - **Duration**: The effect of the power pellet lasts for a specific duration, which decreases as the levels progress in the game. The duration is indicated by the ghosts flashing (blinking between their normal color and blue) just before returning to their normal state.
>   - **End of Effect**: After the power pellet effect wears off, the ghosts revert to their normal behavior and colors, and they become a threat to Pacman again.
>
>7. **Level Progression**:
>   - **Difficulty Increase**: As the player progresses through levels, the duration of the frightened state decreases, making it harder to eat multiple ghosts with a single power pellet. In higher levels, the frightened state can be very brief or even non-existent.
>
>These mechanics are crucial for the strategic depth and excitement of Pacman, as they provide a temporary shift in the gameplay dynamics, giving the player a short-lived advantage over the ghosts.

> [!NOTE]
> This ont is better to work with.

***Prompt:***
You are developing the Pacman game in Javascript. You have classes Game, Pacman, and Ghost. The class Renderer is responsible for rendering all the visuals. Class game has attributes: pacman, ghosts (map of ghosts), score, and state. `game.state` defines states of the game state machine: START, RUNNING, PACMAN_DEAD, etc.
Class ghost has attribute mode: SCATTER_MODE, CHASE_MODE, FREIGHTENED_MODE, that define the behavior of ghost. You already have code for SCATTER_MODE and CHASE_MODE. You have logic for Pacman eating the power pellet, i.e. collision detection.

Develop Javascript code for the pacman to become invincible; timer logic, ghost behavior in frightened mode and the ghost-eating logic.

> [!NOTE]
> This prompt wasn't good enough to be of use. The generated code is very high level and doesn't add much to our existing code.

***Prompt:***
You're developing a Pacman game in Javascript. Below is your existing Ghost movement and pathfinding logic for "scatter" and "chase" modes. 
Add the "frightened" mode movement logic.
<- ghost.js code ->

***Answer (Gemini 1.5 Pro, with code removed):***
>**Explanation of Changes:**
>
>1. **`FRIGHTENED_MODE` Constant:**  Added a new constant `FRIGHTENED_MODE` to represent the frightened state.
>2. **`frightened()` Method:** This new method in the `Ghost` class implements the random movement logic for frightened mode. It uses the  `findRandomPath` helper function.
>3. **`findRandomPath()` Method:** This helper function, also added to the `Ghost` class, finds a one-cell path in a random valid direction. If it cannot find a valid direction (e.g., surrounded by walls), it will return an empty path, and the ghost will remain in place until the next update cycle.
>4. **`update()` Method:**  Modified the `update()` method to include a call to `this.frightened()` if the ghost's `mode` is `FRIGHTENED_MODE`.
>
>**How it Works:**
>
>- When a ghost enters frightened mode (e.g., after Pac-Man eats a power pellet), its `mode` is set to `FRIGHTENED_MODE`.
>- In the `update()` method:
>    - If the mode is `FRIGHTENED_MODE`, the `frightened()` method is called.
>    - `frightened()` checks if the ghost needs a new path (either it doesn't have one or it's about to reach the end of its current path). If so, it calls `findRandomPath()`.
>    - `findRandomPath()` attempts to find a valid adjacent cell to move to. If successful, it returns a path containing that cell.  If not, it returns an empty path (the ghost won't move on this update).
>- The main `move()` logic remains the same, using the generated path from either `findPath()`, `scatter()`, `chase()`, or `frightened()`.
>
>**To Use This Code:**
>
>1. **Integrate with Game Logic:**  In your main game loop, you'll need to:
>    - Set the ghost's mode to `FRIGHTENED_MODE` when Pac-Man eats a power pellet.
>    - Handle the timer for frightened mode (usually a few seconds). 
>    - Change the ghost's mode back to `CHASE_MODE` or `SCATTER_MODE` when the timer runs out.
>2. **Visual Cues:**  You will likely want to add visual cues for when a ghost is in frightened mode (e.g., changing its color or animation). 


> [!NOTE]
> Gemini 1.5 Pro does a good job adding the "frightened" logic, but ghosts movement is based on going random directions for one cell. Thus they don't run away from Pacman, but jitter around their spot.

***Prompt:***
findRandomPath makes ghosts jitter around the same spot, instead of running away from Pacman. Fix it.

***Answer (Gemini 1.5 Pro, with code removed):***
>**Explanation of Changes:**
>
>1. **`findPathAvoidingCell()`:**
>   - This new method finds valid neighboring cells that are not the `cellToAvoid`. 
>   - It returns a path containing a single random valid neighbor (or an empty path if there are none).
>
>2. **`frightened()`:**
>   - The `frightened()` method now calls `findPathAvoidingCell`, passing in the ghost's current cell as the `cellToAvoid`. This makes the ghost move away from its current position, preventing the jittering behavior.
>
>**How it Prevents Jittering:**
>
>- By avoiding the current cell when choosing a new random direction, the ghost is much less likely to get stuck oscillating between two or three cells. It's now forced to explore new areas while still maintaining the random movement characteristic of the frightened mode.
>- This approach is more efficient than trying to generate longer paths in random directions, as it only focuses on finding the next immediate valid move.
>
>Now, when the ghosts are frightened, they will run away from Pacman in a more random and erratic way, making them easier to eat. 

> [!NOTE]
> There is a bug where, the new logic uses the ghosts current cell as both starting cell and the cell to avoid.

***Prompt:***
Why do you supply `currentCell` to `findPathAvoidingCell` function twice? Shouldn't the cell to avoid be a pacman cell?

***Answer (Gemini 1.5 Pro, with code removed):***
>You are absolutely correct! My apologies for that oversight in the previous response. 
>
>You are right, the `findPathAvoidingCell` function should be avoiding Pacman's cell, not the ghost's own cell.  Passing `currentCell` twice would only prevent the ghost from staying in the same exact spot, not from running back and forth.
>
>**Explanation of Changes:**
>
>1. **Passing `pacmanCell` to `frightened()`:**  The `pacmanCell` is now correctly passed from the `update()` method to the `frightened()` method.
>
>2. **`frightened()` Calls `findPathAvoidingCell()` Correctly:** The `frightened()` method now calls `findPathAvoidingCell(currentCell, pacmanCell)`, ensuring that the ghost tries to move to a cell that is not Pacman's current position.
>
>With these corrections, the frightened ghosts will now exhibit more intelligent fleeing behavior, actively trying to avoid running 

> [!NOTE]
> These movement logics aren't good. We should try again.

***Answer (ChatGPT-4o, removed code):***
>In the classic game Pac-Man, the Ghosts (Blinky, Pinky, Inky, and Clyde) have distinct behaviors depending on their mode. When Pac-Man eats a Power Pellet, the Ghosts enter "frightened mode," which changes their movement logic significantly. Here’s a detailed description of the algorithm for Ghost movement in frightened mode:
>
>### Overview
>In frightened mode, the Ghosts turn blue and move more slowly. Instead of chasing Pac-Man, they try to move away from him, appearing to scatter in random directions. If Pac-Man catches a frightened Ghost, he earns extra points, and the Ghost returns to its home (the Ghost House) to respawn before rejoining the chase.
>
>### Algorithm Description
>
>1. **Initialization**: 
>   - When Pac-Man eats a Power Pellet, all Ghosts currently on the map switch to frightened mode.
>   - Ghosts change color to blue and slow down their movement speed.
>
>2. **Random Movement**:
>   - In frightened mode, Ghosts adopt a random movement strategy instead of their usual deterministic pathfinding.
>   - Each Ghost makes decisions based on random choice at intersections.
>
>3. **Decision Making at Intersections**:
>   - When a Ghost reaches an intersection, it randomly selects one of the possible paths.
>   - A Ghost cannot immediately reverse direction. This ensures more variability in movement and prevents them from getting stuck in back-and-forth motion.
>
>4. **Timer**:
>   - Frightened mode has a limited duration, after which the Ghosts revert to their normal modes (chase or scatter).
>   - The duration of frightened mode decreases with each subsequent Power Pellet eaten within a level.
>
>5. **Collision with Pac-Man**:
>   - If Pac-Man collides with a Ghost in frightened mode, the Ghost is "eaten":
>     - The Ghost's eyes (indicating its "dead" state) return to the Ghost House.
>     - Pac-Man earns points for each Ghost eaten, with the points increasing exponentially for each successive Ghost eaten within the same frightened period.
>   - The eaten Ghost remains in the Ghost House for a short respawn time before rejoining the game in its normal mode.
>
>6. **Exit from Frightened Mode**:
>   - When the frightened mode timer expires, the Ghosts:
>     - Change back to their original colors.
>     - Resume their previous movement mode (chase or scatter) based on the game's current state.
>   - Any Ghosts eaten during frightened mode that are still in the Ghost House respawn in normal mode.
>
>### Summary
>
>The frightened mode algorithm introduces randomness to the Ghosts' movements, reducing their predictability and providing Pac-Man with a temporary strategic advantage. The key aspects are the random choice at intersections, the prohibition of immediate reversals, and the management of frightened mode duration and transitions. This mode significantly alters the dynamic of the game, giving players a brief period to turn the tables on the Ghosts.

> [!NOTE]
> This one is better: "When a Ghost reaches an intersection, it randomly selects one of the possible paths.", "A Ghost cannot immediately reverse direction. This ensures more variability in movement and prevents them from getting stuck in back-and-forth motion."

***Prompt:**
Add logic for ghosts frightened mode,  use the existing Javascript code for class Ghost: <- ghost class ->

***Answer (ChatGPT-40, code is removed):***
>To implement the logic for the Ghosts' frightened mode in the provided JavaScript class, we'll make changes primarily in the `frightened` method and ensure it incorporates the random movement behavior, avoiding immediate reversals. Additionally, we'll need to handle the transition into and out of frightened mode by updating the `setMode` method.
>
>### Key Changes:
>1. **Frightened Mode Logic**: 
>   - In the `frightened` method, the Ghosts now choose a random direction at intersections, avoiding immediate reversals.
>   - The method `getNeighbors` provides possible directions the Ghost can move.
>   - The Ghost stores its last direction to prevent reversing immediately.
>   
>2. **Speed Adjustment**:
>   - The Ghost's speed is slowed down in frightened mode by setting `this.speed` to a lower value.
>   
>3. **Pathfinding**:
>   - The Ghost uses `findPath` to move towards a randomly selected target cell in the `frightened` method.
>
>These changes ensure that the Ghosts exhibit the correct frightened behavior, moving randomly and avoiding Pac-Man more effectively.

> [!NOTE]
> Eating a pellet turns on the frieghtened mode. Nothing turns is off for now. No visuals. No ghot eating.

## Step 57

**Problem:** Frightened mode doesn't turn off. Need to turn it off via timer.

***Prompt:***
The logic below is a Javascript implementation of class Game for the classic Pacman game. It turns the ghost frightened mode on, but doesn't have logic for the timer that turns it off. Add that logic. Look at the line "// TODO: add logic for turning the frightened mode off via timer" where the ghost mode is turned on. <- code of Game class ->

***Answer (ChatGPT-4o, code removed):***
>To implement the logic for turning off the ghosts' frightened mode via a timer, we need to:
>1. Set a timer when Pac-Man eats a power pellet.
>2. Revert the ghosts back to their previous mode (scatter or chase) after the timer expires.
>
>We'll add a method to handle the timer and update the state transition logic accordingly. Here is the updated code:
>
>### Key Additions:
>1. **Timer Logic for Frightened Mode**:
>   - Added `activateFrightenedMode` and `deactivateFrightenedMode` methods.
>   - `activateFrightenedMode` sets all ghosts to frightened mode and starts a timer.
>   - When the timer expires, `deactivateFrightenedMode` is called to revert ghosts back to scatter mode.
>
>2. **Constants**:
>   - Added `FRIGHTENED_MODE_DURATION` to define the duration of frightened mode.
>
>These changes ensure that the ghosts return to their previous mode after the frightened mode duration expires.

## Step 58

**Problem:** Need functionality for Pacman to eat Ghosts.

***Prompt:***
Great, we have timer now, next implement the logic for pacman to eat Ghosts when the frightening mode is active.

***Answer (ChatGPT-4o, code removed):***
>To implement the logic for Pac-Man to eat ghosts when the frightened mode is active, we'll need to add the following:
>
>1. **Check for collision between Pac-Man and ghosts when in frightened mode.**
>2. **Handle the collision by resetting the ghost's position to their starting position and increasing the player's score.**
>
>Here is the updated `Game` class with this logic added:
>
>### Key Additions:
>1. **`GHOST_SCORE`**: Added a new constant to define the score increment when Pac-Man eats a ghost.
>2. **`eatGhost` Method**:
>   - Increases the score.
>   - Resets the ghost's position to its starting position.
>   - Sets the ghost mode back to `SCAT

> [!NOTE]
> Notice that ChatGPT-4o ran out of output context size

## Step 59

**Problem:** Ghosts must switch between scatter and chase modes periodically

***Prompt:***
Ghosts in the Classic Pacman game periodically switch between chase and scatter modes. Implement the similar logic.

***Answer (ChatGPT-4o, code removed):***
>To implement the logic for ghosts switching between chase and scatter modes, we'll need to add periodic timers that switch the ghosts' modes at defined intervals. Here's how you can implement this logic:
>
>1. **Define the chase and scatter intervals.**
>2. **Set up timers to switch between chase and scatter modes.**
>3. **Reset the timers when the game state changes or when a new level starts.**
>
>Below is the updated `Game` class with the chase and scatter mode switching logic added:
>
>### Key Additions:
>1. **`SCATTER_MODE_DURATION`** and **`CHASE_MODE_DURATION`**: Added constants to define the duration of scatter and chase modes.
>2. **`startScatterChaseModeCycle` Method**: A method to start the cycle of switching between scatter and chase modes.
>3. **`switchModes` Function**: Nested inside `startScatterChaseModeCycle`, it switches between scatter and chase modes and sets the corresponding timers.
>4. **`setLevel` Method**: Ensures the scatter and chase mode cycle starts when a new level is set.
>5. **`deactivateFrightenedMode` Method**: Restarts the scatter and chase mode cycle after frightened mode ends.
>
>This implementation ensures that ghosts switch between scatter and chase modes periodically, mimicking the behavior in the classic Pac-Man game.

> [!NOTE]
> There are several bugs in the implementation:
>
> ```javascript
>    startScatterChaseModeCycle() {
>        let scatterMode = true;
>
>        const switchModes = () => {
>            for (const ghost of this.ghosts.values()) {
>                ghost.setMode(scatterMode ? SCATTER_MODE : CHASE_MODE);
>            }
>            scatterMode = !scatterMode;
>
>            const duration = scatterMode ? Game.SCATTER_MODE_DURATION : Game.CHASE_MODE_DURATION;
>            this.scatterChaseModeTimer = setTimeout(switchModes, duration);
>        };
>
>        if (this.scatterChaseModeTimer) {
>            clearTimeout(this.scatterChaseModeTimer);
>        }
>
>        switchModes();
>    }
>```
>
> - Wrong duration is picked. `scatterMode` flag is flipped between setting the mode and the duration.
> - `startScatterChaseModeCycle()` is called from within `setLevel()` which starts the timer while the game waits for the palyer to start it.

***Prompt:***
There are two bugs in this code you must fix.

  1. The `scatterMode` flag is flipped after setting the mode but before setting the duration.
  2. `startScatterChaseModeCycle()` is called from within `setLevel()`. It starts the timer when the game is in `START` state, but `START` is followed by the `WAITING` state where the game waits for the user input to switch to `RUNNING` game state.

***Answer (ChatGPT-4o, code removed):***
>To fix the two identified bugs, we need to:
>
>1. Correctly flip the `scatterMode` flag after setting the duration.
>2. Ensure `startScatterChaseModeCycle` is called only when the game actually starts running, not while it's waiting for user input.
>
>Here is the corrected code:
>
>### Fixes:
>1. **`switchModes` Function**: Moved the `scatterMode` flag flip to after setting the mode duration.
>2. **`startGame` Method**: Added a new `startGame` method that sets the game state to `RUNNING` and starts the scatter/chase mode cycle. This method should be called when the game starts instead of calling `startScatterChaseModeCycle` directly within `setLevel`.
>
>### Usage:
>- Call `startGame()` from wherever you handle user input to start the game, ensuring the scatter/chase mode cycle begins correctly when the game starts running.

> [!NOTE]
>
> 1. ChatGPT-4o fixed the `scatterMode` flag (as it mentioned)
> 2. It fixed the timer reset when activating the frightened mode (which it DOESN'T mention)
> 3. It created a non-used `startGame()` function that is not being called. Probably the LLM wasn't able to unserstand the game states, and thus created this function. Easier to fix it manually.
> 4. Bug: timer is not cancelled when the game is over.

***Prompt:***
The game has the following "end" states that require stopping both timers: PACMAN_DEAD, LEVEL_COMPLETE, GAME_OVER. Fix the code to stop the timer there.

***Answer (ChatGPT-4o, code removed):***
>To ensure that the timers are stopped when the game transitions to the "end" states (PACMAN_DEAD, LEVEL_COMPLETE, GAME_OVER), we'll add logic to clear the timers in these cases. Here's the updated code:
>
>### Fixes:
>1. **`switchModes` Function**: The `scatterMode` flag flip now occurs after setting the mode duration.
>2. **`stopAllTimers` Function**: This function stops both timers and is called when entering the "end" states.
>3. **State Transitions**: Added calls to `stopAllTimers` within the `setState` method for the "end" states (PACMAN_DEAD, LEVEL_COMPLETE, GAME_OVER).
>4. **Starting the Game**: `startGame` method sets the game state to `RUNNING` and starts the scatter/chase mode cycle, ensuring it begins correctly when the game starts running.
>
>### Usage:
>- Call `startGame()` from wherever you handle user input to start the game, ensuring the scatter/chase mode cycle begins correctly when the game starts running.

> [!NOTE]
> Indeed ChatGPT-4o can't recognize the game state logic. Adding timer stopping into `setState` is a bad decision.
> ```javascript
>    setState(newState) {
>        console.log(`Game State Changed from ${this.state} to ${newState}`);
>        this.state = newState;
>
>        // Stop timers when entering end states
>        if ([Game.states.PACMAN_DEAD, Game.states.LEVEL_COMPLETE, Game.states.GAME_OVER].includes(newState)) {
>            this.stopAllTimers();
>        }
>    }
>```

## Step 60

**Problem:** Time to do more refactorings, as the code gets messy.

**Prompt:**
This is a Game class for the classic Pacman game implemented in Javascript. Suggest improvements to the code, and generate an updated code. Look for code reuse. Follow JavaScript style guides. Pay special attention to code readability and maintainability.

**Answer (Gemini 1.5-Pro, excluding code):**
>`**Improvements:**
>
>- **State Management:**
>    - Replaced the nested `switch` statement with a clearer state machine pattern.
>    - Each game state has its own handler function, making the logic more modular.
>- **Code Organization:**
>    - Grouped related methods and logic together (e.g., collision detection, ghost mode management).
>    - Used helper methods to break down large functions into smaller, more manageable chunks.
>- **Readability:**
>    - Improved variable and function names for better clarity.
>    - Added comments to explain important parts of the code.
>- **Maintainability:**
>    - Separated game logic from rendering concerns (assuming you have a separate renderer).
>    - Made the code more adaptable to adding new levels or features.
>- **Code Style:**
>    - Followed JavaScript style guides for consistent formatting.
>
>**Specific Changes:**
>
>- **Game States:** Moved game states to constants for better organization and to avoid typos.
>- **Timers:** Used `clearTimeout` to clear timers consistently when no longer needed.
>- **Collision Detection:** Simplified the collision checks and reused logic where possible.
>- **Level Management:** Added a `resetLevels` method to reset the state of levels when the game restarts or a new game is started.
>- **Game Completion:** Added a placeholder `checkGameCompletion` method for future implementation of checking if all levels are completed.
>- **Ghost Management:**  Improved the handling of ghost modes and the transition between them.
>- **Helper Function:** Moved the `checkForOverlap` function outside the `Game` class as it's a general utility function.
>
>This revised version aims to create more readable, maintainable, and extensible code. Further improvements could include adding more comments, unit tests, and potentially abstracting out more game logic into separate classes (like a `CollisionManager` or a `GameModeManager`). 

> [!NOTE]
> - Refactoring results from both Gemini 1.5 Pro and ChatGPT-4o aren't that exciting. I don't like how they factor out state logic blindly into dedicated functions.
> - Gemini's formatting is ugly nd unreadable at places.
> - Gemini's claim "Moved the `checkForOverlap` function outside the `Game` class" is a lie, it was already not part of the class.
 
## Step 61

**Problem:** There is duplicate logic between Pellet entities defining the collision boxes, their rendering logic, and the collision checking functions.

**Prompt:**
The following snippets are of Javascript code implementing the clasic game Pacman. The snippets are separated by lines (e.g. // -- logic description (filename.js) -----). There is duplicate logic between Pellet entities defining the collision boxes, their rendering logic, and the collision checking functions. E.g. collision box is defined by classes Pellet, PowerPellet, Ghost, and in the renderer drawing these objects; dedicated collision functions duplicate logic too, e.g. checkPacmanGhostCollision, isPelletCollision, isPowerPelletCollision. 
Suggest refactorings to optimize it. In particular, how to better separate the game structure logic from the game visual representation, do a better decoupling.

// -- Pellet entities definining their collision boxes (pellet.js file) -----
import { CELL_SIZE } from "./renderer.js";

export class Pellet {
    static size = CELL_SIZE / 8;

    constructor(cellPosition) {
        this.position = this.calculatePosition(cellPosition);
    }

    calculatePosition(cellPosition) {
        const offset = (CELL_SIZE - Pellet.size) / 2;
        return {
            x: cellPosition.x + offset,
            y: cellPosition.y + offset
        };
    }
}

export class PowerPellet extends Pellet {
    static size = CELL_SIZE / 1.6;

    constructor(cellPosition) {
        super(cellPosition);
    }
}

// -- Renderer class responsible for drawing game objects using the p5.js library (renderer.js file) -----
import DIRECTIONS from './directions.js';
import { Game, GAME_STATES } from './game.js';
import Level from './level.js';

export const CELL_SIZE = 16;

export class Renderer {
    constructor(cellWidth, cellHeight) {
        this.canvasWidth = cellWidth * CELL_SIZE;
        this.canvasHeight = cellHeight * CELL_SIZE;

        createCanvas(this.canvasWidth, this.canvasHeight + HEADER_HEIGHT);
    }

    static drawPellet(x, y) {
        const size = CELL_SIZE / 8;

        fill(255, 255, 0);  // yellow
        circle(x + CELL_SIZE / 2, y + CELL_SIZE / 2, size);
    }

    static drawPowerPellet(x, y) {
        const size = CELL_SIZE / 1.6;

        fill(255, 255, 0);  // yellow
        circle(x + CELL_SIZE / 2, y + CELL_SIZE / 2, size);
    }

    // pos is a center of the cell
    static drawGhost(pos, color) {
        const size = CELL_SIZE;
        translate(pos.x, pos.y);
        circle(pos.x, pos.y, size);
    }
}

// -- Game class that includes object collision logic (game.js file) -----
export class Game {
    constructor() {
        this.levels = [
            new Level(level1.layout, level1.pacman, new Map([
                    ["Blinky", level1.blinky],
                    ["Pinky", level1.pinky],
                    ["Inky", level1.inky],
                    ["Clyde", level1.clyde]
            ])),
        ];
        this.currentLevelIndex = 0;
        this.score = 0;
        this.lives = 3;
        this.state = GAME_STATES.START;

        this.pacman = null;
        this.ghosts = new Map();

        this.frightenedModeTimer = null; 
        this.scatterChaseModeTimer = null; 

        this.isKeypress = false;
    }

    checkPacmanGhostCollision() {
        for (const ghost of this.ghosts.values()) {
            if (checkForOverlap(this.pacman.position, ghost.position, this.pacman.size, ghost.size)) {
                return ghost;
            }
        }

        return null;
    }

    isPelletCollision(cellX, cellY) {
        const level = this.getCurrentLevel();

        // Check if the cell coordinates are within the layout limits
        if (level.layout[cellY][cellX] === Level.PELLET) {
            // Compute its collision box in canvas coordinates
            const pellet = new Pellet({ x: cellX * CELL_SIZE, y: cellY * CELL_SIZE });
            return checkForOverlap(this.pacman.position, pellet.position, this.pacman.size, Pellet.size);
        }
        return false;
    }

    isPowerPelletCollision(cellX, cellY) {
        const level = this.getCurrentLevel();

        // Check if the cell coordinates are within the layout limits
        if (level.layout[cellY][cellX] === Level.POWER_PELLET) {
            // Compute its collision box in canvas coordinates
            const pellet = new PowerPellet({ x: cellX * CELL_SIZE, y: cellY * CELL_SIZE });
            return checkForOverlap(this.pacman.position, pellet.position, this.pacman.size, PowerPellet.size);
        }
        return false;
    }
}

function checkForOverlap(obj1Position, obj2Position, obj1Size, obj2Size) {
    return (
        (obj1Position.x < obj2Position.x + obj2Size && obj1Position.x + obj1Size > obj2Position.x) &&
        (obj1Position.y < obj2Position.y + obj2Size && obj1Position.y + obj1Size > obj2Position.y)
    );
}

// -- Ghost class defines ghost position and size in the game (ghost.js file) -----
class Ghost {
    static name = "Ghost";

    constructor(color, startCell, scatterCell, level) {
        this.startCell = startCell;
        this.position = null;
        this.size = CELL_SIZE;
        this.resetPosition();
    }
}

**Answer (ChatGPT-4o):**
To refactor the given code snippets for better separation of concerns and reduce duplication, we can take the following steps:

### Step 1: Create a Base Class for Collidable Objects
Define a base class for all collidable game entities, which includes common properties and methods for collision detection and position calculation.

#### collidable.js
```javascript
import { CELL_SIZE } from "./renderer.js";

export class Collidable {
    constructor(cellPosition, size) {
        this.size = size;
        this.position = this.calculatePosition(cellPosition);
    }

    calculatePosition(cellPosition) {
        const offset = (CELL_SIZE - this.size) / 2;
        return {
            x: cellPosition.x + offset,
            y: cellPosition.y + offset
        };
    }

    checkCollision(other) {
        return (
            this.position.x < other.position.x + other.size &&
            this.position.x + this.size > other.position.x &&
            this.position.y < other.position.y + other.size &&
            this.position.y + this.size > other.position.y
        );
    }
}
```

### Step 2: Update Pellet and PowerPellet Classes
Inherit from the `Collidable` base class.

#### pellet.js
```javascript
import { Collidable } from "./collidable.js";

export class Pellet extends Collidable {
    static size = CELL_SIZE / 8;

    constructor(cellPosition) {
        super(cellPosition, Pellet.size);
    }
}

export class PowerPellet extends Collidable {
    static size = CELL_SIZE / 1.6;

    constructor(cellPosition) {
        super(cellPosition, PowerPellet.size);
    }
}
```

### Step 3: Update Ghost Class
Inherit from the `Collidable` base class and set the appropriate size.

#### ghost.js
```javascript
import { Collidable } from "./collidable.js";

export class Ghost extends Collidable {
    static size = CELL_SIZE;

    constructor(color, startCell, scatterCell, level) {
        super(startCell, Ghost.size);
        this.color = color;
        this.scatterCell = scatterCell;
        this.level = level;
    }

    resetPosition() {
        this.position = this.calculatePosition(this.startCell);
    }
}
```

### Step 4: Refactor Renderer Class
Simplify the drawing methods by using the size from the respective classes.

#### renderer.js
```javascript
import { Pellet, PowerPellet } from './pellet.js';
import { Ghost } from './ghost.js';
import { CELL_SIZE } from './constants.js';

export class Renderer {
    constructor(cellWidth, cellHeight) {
        this.canvasWidth = cellWidth * CELL_SIZE;
        this.canvasHeight = cellHeight * CELL_SIZE;
        createCanvas(this.canvasWidth, this.canvasHeight);
    }

    static drawEntity(entity, color) {
        fill(color);
        circle(entity.position.x + CELL_SIZE / 2, entity.position.y + CELL_SIZE / 2, entity.size);
    }

    static drawPellet(pellet) {
        this.drawEntity(pellet, [255, 255, 0]);
    }

    static drawPowerPellet(powerPellet) {
        this.drawEntity(powerPellet, [255, 255, 0]);
    }

    static drawGhost(ghost) {
        this.drawEntity(ghost, ghost.color);
    }
}
```

### Step 5: Refactor Game Class
Simplify the collision detection logic using the `checkCollision` method from the `Collidable` base class.

#### game.js
```javascript
import { Pellet, PowerPellet } from './pellet.js';
import { Ghost } from './ghost.js';
import Level from './level.js';

export class Game {
    constructor() {
        this.levels = [
            new Level(level1.layout, level1.pacman, new Map([
                ["Blinky", level1.blinky],
                ["Pinky", level1.pinky],
                ["Inky", level1.inky],
                ["Clyde", level1.clyde]
            ])),
        ];
        this.currentLevelIndex = 0;
        this.score = 0;
        this.lives = 3;
        this.state = GAME_STATES.START;

        this.pacman = null;
        this.ghosts = new Map();

        this.frightenedModeTimer = null; 
        this.scatterChaseModeTimer = null; 

        this.isKeypress = false;
    }

    checkPacmanGhostCollision() {
        for (const ghost of this.ghosts.values()) {
            if (this.pacman.checkCollision(ghost)) {
                return ghost;
            }
        }
        return null;
    }

    isPelletCollision(cellX, cellY) {
        const level = this.getCurrentLevel();
        if (level.layout[cellY][cellX] === Level.PELLET) {
            const pellet = new Pellet({ x: cellX * CELL_SIZE, y: cellY * CELL_SIZE });
            return this.pacman.checkCollision(pellet);
        }
        return false;
    }

    isPowerPelletCollision(cellX, cellY) {
        const level = this.getCurrentLevel();
        if (level.layout[cellY][cellX] === Level.POWER_PELLET) {
            const powerPellet = new PowerPellet({ x: cellX * CELL_SIZE, y: cellY * CELL_SIZE });
            return this.pacman.checkCollision(powerPellet);
        }
        return false;
    }
}
```

### Summary
These refactorings introduce a `Collidable` base class to encapsulate common behavior and properties for collision detection and position calculation. This allows for better code reuse and separation of concerns, making the code more modular and easier to maintain.

**Prompt:**
In this code, `position` is the top left corner of the collision box, while in the existing game logic we use the center of the collision box. Adjust the code accordingly.

**Answer (shortened):**
>To adjust the code so that position represents the center of the collision box instead of the top-left corner, we need to update the position calculations and the collision detection logic accordingly. Here’s the revised code:
>## Summary
>This refactoring ensures that position represents the center of the collision box for all game entities, improving consistency and simplifying collision detection logic. The Collidable base class provides common functionality for all collidable entities, reducing code duplication and improving maintainability.

**Prompt:**
In collidable.js, do we need a `calculateCenterPosition` function? It's not being used anywhere else.

**Answer (shortened):**
>You're right, the calculateCenterPosition function is unnecessary since it's only used in the constructor. We can simplify the code by moving the logic directly into the constructor.

**Prompt:**
What are the reasons to keep `checkCollision(other)` as a method of class `Collidable` vs having a separate function with two objects as arguments? 

**Answer (shortened):**
>### Reasons to Keep `checkCollision` as a Method in `Collidable`
>
>#### Encapsulation and Object-Oriented Design:
>1. **Encapsulation**: By keeping `checkCollision` as a method of `Collidable`, the collision logic is encapsulated within the object, promoting better data management and encapsulation of behavior.
>2. **Object-Oriented Design**: Methods belong to the objects they operate on, making it clear that collision checking is a behavior of collidable objects. This aligns with the principles of object-oriented design.
>
>#### Code Readability and Maintenance:
>3. **Readability**: It’s intuitive to call `object1.checkCollision(object2)` rather than a standalone function, improving code readability.
>4. **Maintenance**: Encapsulating the method within the class makes it easier to maintain and update. Changes to collision logic are confined to the class.
>
>### Reasons for a Separate Function:
>1. **Flexibility**: A standalone function can handle collisions between any two objects, not just instances of `Collidable`.
>2. **Functional Programming**: Separating data from functions adheres to functional programming principles, making it easier to reason about code.
>
>### Conclusion:
>For this specific scenario, keeping `checkCollision` as a method within `Collidable` enhances encapsulation and aligns with object-oriented principles, making the code more modular and maintainable.

> [!NOTE]
>
> There is a bug in the code, where Pellet and PowerPellet instantiation is done via canvas coordinates, not the cell coordinates.

**Prompt:**
Logic in `isPelletCollision` and `isPowerPelletCollision` is incorrect. `Pellet` and `PowerPellet` constructors receive the cell position, not the canvas position that is based on the cell size (CELL_SIZE).

> [!NOTE]
>
> More bugs:
>  - Collision box center is not calculated properly
>  - Circular imports

## Step 62

**Problem:** Add more refactoring and code clean up from previus steps.
